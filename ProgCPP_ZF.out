\BOOKMARK [0][-]{part.1}{I Einf\374hrung}{}% 1
\BOOKMARK [1][-]{section.1}{Charakteristiken von C++}{part.1}% 2
\BOOKMARK [1][-]{section.2}{Entstehung von C++}{part.1}% 3
\BOOKMARK [1][-]{section.3}{Welches C++?}{part.1}% 4
\BOOKMARK [1][-]{section.4}{C++-Unterst\374tzung von Texas Instruments \(TI\)}{part.1}% 5
\BOOKMARK [1][-]{section.5}{Hello World!}{part.1}% 6
\BOOKMARK [1][-]{section.6}{C++-Compiler \(noch nicht Eclipse\)}{part.1}% 7
\BOOKMARK [1][-]{section.7}{Lexikalische Elemente von C++}{part.1}% 8
\BOOKMARK [1][-]{section.8}{Styleguide: Bezeichner \(\037Namen\)}{part.1}% 9
\BOOKMARK [1][-]{section.9}{Typkonzept}{part.1}% 10
\BOOKMARK [2][-]{subsection.9.1}{Datentypen}{section.9}% 11
\BOOKMARK [2][-]{subsection.9.2}{\043define}{section.9}% 12
\BOOKMARK [1][-]{section.10}{Ausdr\374cke und Operatoren}{part.1}% 13
\BOOKMARK [1][-]{section.11}{Anweisungen}{part.1}% 14
\BOOKMARK [1][-]{section.12}{Streams}{part.1}% 15
\BOOKMARK [2][-]{subsection.12.1}{Streamkonzept}{section.12}% 16
\BOOKMARK [2][-]{subsection.12.2}{Einsatz von Streams}{section.12}% 17
\BOOKMARK [2][-]{subsection.12.3}{Ausgabe: Klasse ostream}{section.12}% 18
\BOOKMARK [2][-]{subsection.12.4}{Eingabe: Klasse istream}{section.12}% 19
\BOOKMARK [2][-]{subsection.12.5}{Formatierte Ein- und Ausgabe}{section.12}% 20
\BOOKMARK [3][-]{subsubsection.12.5.1}{Format-Flags um \334berblick \(unvollst\344ndig\)}{subsection.12.5}% 21
\BOOKMARK [0][-]{part.2}{II Funktionen}{}% 22
\BOOKMARK [1][-]{section.13}{Grundlegendes}{part.2}% 23
\BOOKMARK [2][-]{subsection.13.1}{Synonyme f\374r Funktionen}{section.13}% 24
\BOOKMARK [2][-]{subsection.13.2}{Aufgabe einer Funktion}{section.13}% 25
\BOOKMARK [2][-]{subsection.13.3}{Funktionen \(Vergleich zu C\)}{section.13}% 26
\BOOKMARK [2][-]{subsection.13.4}{Definition von Funktionen}{section.13}% 27
\BOOKMARK [2][-]{subsection.13.5}{Deklaration von Funktionen \(Funktionsprototypen\)}{section.13}% 28
\BOOKMARK [2][-]{subsection.13.6}{Kosten einer Funktion}{section.13}% 29
\BOOKMARK [1][-]{section.14}{C-Makro}{part.2}% 30
\BOOKMARK [2][-]{subsection.14.1}{C-Makro mit \043define}{section.14}% 31
\BOOKMARK [2][-]{subsection.14.2}{Beispiel mit C-Makro: Maximum zweier int-Werte}{section.14}% 32
\BOOKMARK [3][-]{subsubsection.14.2.1}{Was passiert wirklich?}{subsection.14.2}% 33
\BOOKMARK [1][-]{section.15}{inline-Funktionen}{part.2}% 34
\BOOKMARK [2][-]{subsection.15.1}{Grundlegendes}{section.15}% 35
\BOOKMARK [2][-]{subsection.15.2}{Beispiel mit inline-Code: Maximum zweier int-Werte}{section.15}% 36
\BOOKMARK [1][-]{section.16}{Grunds\344tze f\374r Optimierungen}{part.2}% 37
\BOOKMARK [1][-]{section.17}{default-Argumente}{part.2}% 38
\BOOKMARK [2][-]{subsection.17.1}{Vorbelegte Parameter \(default-Argumente\)}{section.17}% 39
\BOOKMARK [3][-]{subsubsection.17.1.1}{Beispiel: default-Argumente}{subsection.17.1}% 40
\BOOKMARK [2][-]{subsection.17.2}{Nutzen von default-Argumenten}{section.17}% 41
\BOOKMARK [1][-]{section.18}{Overloading}{part.2}% 42
\BOOKMARK [2][-]{subsection.18.1}{\334berladen von Funktionen \(overloading\)}{section.18}% 43
\BOOKMARK [2][-]{subsection.18.2}{Overloading in C++}{section.18}% 44
\BOOKMARK [3][-]{subsubsection.18.2.1}{Deklaration von \374berladenen Funktionen: Regeln}{subsection.18.2}% 45
\BOOKMARK [3][-]{subsubsection.18.2.2}{Funktionen sollen nur dann \374berladen werden, wenn ...}{subsection.18.2}% 46
\BOOKMARK [1][-]{section.19}{default-Parameter vs. Overloading}{part.2}% 47
\BOOKMARK [0][-]{part.3}{III Pointer und Referenzen}{}% 48
\BOOKMARK [1][-]{section.20}{H\366here und strukturierte Datentypen}{part.3}% 49
\BOOKMARK [2][-]{subsection.20.1}{H\366here Datentypen}{section.20}% 50
\BOOKMARK [2][-]{subsection.20.2}{Strukturierte Datentypen}{section.20}% 51
\BOOKMARK [1][-]{section.21}{Pointer}{part.3}% 52
\BOOKMARK [2][-]{subsection.21.1}{Adresse}{section.21}% 53
\BOOKMARK [2][-]{subsection.21.2}{Standarddarstellung von Pointern}{section.21}% 54
\BOOKMARK [2][-]{subsection.21.3}{Pointer und Datentyp}{section.21}% 55
\BOOKMARK [2][-]{subsection.21.4}{Definition einer Pointervariablen}{section.21}% 56
\BOOKMARK [3][-]{subsubsection.21.4.1}{Initialisierung mit Null-Pointer}{subsection.21.4}% 57
\BOOKMARK [3][-]{subsubsection.21.4.2}{Der Adressoperator \046 \(Referenzierung\)}{subsection.21.4}% 58
\BOOKMARK [3][-]{subsubsection.21.4.3}{Kopieren von Adressen}{subsection.21.4}% 59
\BOOKMARK [3][-]{subsubsection.21.4.4}{Der Inhaltsoperator * \(Dereferenzierung\)}{subsection.21.4}% 60
\BOOKMARK [3][-]{subsubsection.21.4.5}{const bei Pointern: Vorsicht}{subsection.21.4}% 61
\BOOKMARK [3][-]{subsubsection.21.4.6}{void-Pointer}{subsection.21.4}% 62
\BOOKMARK [3][-]{subsubsection.21.4.7}{Pointer auf Funktionen}{subsection.21.4}% 63
\BOOKMARK [3][-]{subsubsection.21.4.8}{Interruptvektortabelle: Tabelle von Funktionspointern}{subsection.21.4}% 64
\BOOKMARK [3][-]{subsubsection.21.4.9}{Umsetzung von Funktionspointern in C/C++}{subsection.21.4}% 65
\BOOKMARK [3][-]{subsubsection.21.4.10}{Beispiel f\374r Funktionspointer}{subsection.21.4}% 66
\BOOKMARK [1][-]{section.22}{Referenzen}{part.3}% 67
\BOOKMARK [2][-]{subsection.22.1}{Syntax}{section.22}% 68
\BOOKMARK [2][-]{subsection.22.2}{Einsatz}{section.22}% 69
\BOOKMARK [1][-]{section.23}{Pointer und Referenzen auf lokale Variablen}{part.3}% 70
\BOOKMARK [1][-]{section.24}{Zeiger und Referenzen als Parameter und R\374ckgabewerte}{part.3}% 71
\BOOKMARK [2][-]{subsection.24.1}{Call by Value vs. Call by Reference}{section.24}% 72
\BOOKMARK [3][-]{subsubsection.24.1.1}{3 Beispiele}{subsection.24.1}% 73
\BOOKMARK [2][-]{subsection.24.2}{Call by reference: wann einsetzen?}{section.24}% 74
\BOOKMARK [2][-]{subsection.24.3}{Merke}{section.24}% 75
\BOOKMARK [0][-]{part.4}{IV Arrays, Dynamische Speicherverwaltung}{}% 76
\BOOKMARK [1][-]{section.25}{Arrays}{part.4}% 77
\BOOKMARK [2][-]{subsection.25.1}{Arrays: Vektoren}{section.25}% 78
\BOOKMARK [2][-]{subsection.25.2}{Der Array \(Feld, Vektor\)}{section.25}% 79
\BOOKMARK [3][-]{subsubsection.25.2.1}{Zugriff auf ein Arrayelement}{subsection.25.2}% 80
\BOOKMARK [2][-]{subsection.25.3}{Arrays und Pointer}{section.25}% 81
\BOOKMARK [3][-]{subsubsection.25.3.1}{Pro Memoria: Eindimensionales Array \(Vektor\)}{subsection.25.3}% 82
\BOOKMARK [2][-]{subsection.25.4}{\304quivalenz von Array- und Pointernotation}{section.25}% 83
\BOOKMARK [2][-]{subsection.25.5}{Vergleichen von Arrays}{section.25}% 84
\BOOKMARK [2][-]{subsection.25.6}{Der Arrayname ist ein nicht modifizierbarer L-Wert}{section.25}% 85
\BOOKMARK [2][-]{subsection.25.7}{Automatische Initialisierung von Arrays}{section.25}% 86
\BOOKMARK [2][-]{subsection.25.8}{Explizite Initialisierung von Arrays}{section.25}% 87
\BOOKMARK [3][-]{subsubsection.25.8.1}{Beispiel}{subsection.25.8}% 88
\BOOKMARK [3][-]{subsubsection.25.8.2}{Goodies f\374r die explizite Initialisierung}{subsection.25.8}% 89
\BOOKMARK [2][-]{subsection.25.9}{Mehrdimensionale Arrays}{section.25}% 90
\BOOKMARK [3][-]{subsubsection.25.9.1}{Initialisierung eines mehrdimensionalen Arrays}{subsection.25.9}% 91
\BOOKMARK [1][-]{section.26}{\334bergabe von Arrays und Zeichenketten}{part.4}% 92
\BOOKMARK [2][-]{subsection.26.1}{Beispiel: Array \(Vektor\) als Parameter}{section.26}% 93
\BOOKMARK [2][-]{subsection.26.2}{\334bergabe einer Matrix mittels offenem Array}{section.26}% 94
\BOOKMARK [2][-]{subsection.26.3}{Zeichenketten \(Strings\)}{section.26}% 95
\BOOKMARK [1][-]{section.27}{Dynamische Speicherverwaltung}{part.4}% 96
\BOOKMARK [2][-]{subsection.27.1}{Pro Memoria: Variablen}{section.27}% 97
\BOOKMARK [2][-]{subsection.27.2}{Dynamische Speicherverwaltung}{section.27}% 98
\BOOKMARK [2][-]{subsection.27.3}{Syntax}{section.27}% 99
\BOOKMARK [2][-]{subsection.27.4}{Vorsichtsmassnahmen}{section.27}% 100
\BOOKMARK [2][-]{subsection.27.5}{Memory Leak, Garbage Collection}{section.27}% 101
\BOOKMARK [2][-]{subsection.27.6}{Dynamische Allozierung von Arrays}{section.27}% 102
\BOOKMARK [2][-]{subsection.27.7}{Dynamische Allozierung von Matrizen}{section.27}% 103
\BOOKMARK [3][-]{subsubsection.27.7.1}{Dynamische Matrix mit 4 Zeilen und 3 Spalten}{subsection.27.7}% 104
\BOOKMARK [3][-]{subsubsection.27.7.2}{Zugriff auf dynamisch erzeugte Matrix}{subsection.27.7}% 105
\BOOKMARK [3][-]{subsubsection.27.7.3}{Dynamische Matrix freigeben}{subsection.27.7}% 106
\BOOKMARK [2][-]{subsection.27.8}{Effizienz der Matriximplementationen}{section.27}% 107
\BOOKMARK [0][-]{part.5}{V Scope, Deklarationen, Type Casts}{}% 108
\BOOKMARK [1][-]{section.28}{Strukturen in C++}{part.5}% 109
\BOOKMARK [1][-]{section.29}{G\374ltigkeitsbereiche, Namensr\344ume und Sichtbarkeit}{part.5}% 110
\BOOKMARK [2][-]{subsection.29.1}{G\374ltigkeitsbereiche von Namen \(Scope\)}{section.29}% 111
\BOOKMARK [2][-]{subsection.29.2}{G\374ltigkeitsbereiche in C++}{section.29}% 112
\BOOKMARK [2][-]{subsection.29.3}{G\374ltigkeit \(Scope\) von Variablen}{section.29}% 113
\BOOKMARK [2][-]{subsection.29.4}{Lebensdauer von Variablen}{section.29}% 114
\BOOKMARK [2][-]{subsection.29.5}{Sichtbarkeit von Variablen}{section.29}% 115
\BOOKMARK [2][-]{subsection.29.6}{Schlussfolgerung \(naheliegend aber falsch\)}{section.29}% 116
\BOOKMARK [2][-]{subsection.29.7}{Lebensdauer \(grau\) und Sichtbarkeit \(weiss\)}{section.29}% 117
\BOOKMARK [2][-]{subsection.29.8}{Codierstil}{section.29}% 118
\BOOKMARK [1][-]{section.30}{Namensr\344ume \(Namespaces\)}{part.5}% 119
\BOOKMARK [2][-]{subsection.30.1}{Explizite Namensr\344ume in C++}{section.30}% 120
\BOOKMARK [2][-]{subsection.30.2}{C++-Mechanismen f\374r Namespaces}{section.30}% 121
\BOOKMARK [2][-]{subsection.30.3}{Deklaration von Namespaces}{section.30}% 122
\BOOKMARK [3][-]{subsubsection.30.3.1}{Beispiel}{subsection.30.3}% 123
\BOOKMARK [2][-]{subsection.30.4}{using-Deklaration}{section.30}% 124
\BOOKMARK [2][-]{subsection.30.5}{using-Direktive}{section.30}% 125
\BOOKMARK [2][-]{subsection.30.6}{using namespace kann zu Konflikten f\374hren}{section.30}% 126
\BOOKMARK [2][-]{subsection.30.7}{Namenlose Namespaces}{section.30}% 127
\BOOKMARK [2][-]{subsection.30.8}{Zugriff auf globale Variable mit Scope-Operator}{section.30}% 128
\BOOKMARK [1][-]{section.31}{Speicherklassen}{part.5}% 129
\BOOKMARK [2][-]{subsection.31.1}{Speicherklassen in C++}{section.31}% 130
\BOOKMARK [3][-]{subsubsection.31.1.1}{Speicherklasse static: Variablen}{subsection.31.1}% 131
\BOOKMARK [3][-]{subsubsection.31.1.2}{Speicherklasse static: Funktionen}{subsection.31.1}% 132
\BOOKMARK [3][-]{subsubsection.31.1.3}{Speicherklasse extern: Externe Variablen}{subsection.31.1}% 133
\BOOKMARK [2][-]{subsection.31.2}{Typqualifikationen \(Kap. 9.2.2\)}{section.31}% 134
\BOOKMARK [2][-]{subsection.31.3}{Funktionsattribute}{section.31}% 135
\BOOKMARK [1][-]{section.32}{Typdefinitionen}{part.5}% 136
\BOOKMARK [2][-]{subsection.32.1}{typedef zur Vereinbarung eigener Datentypen}{section.32}% 137
\BOOKMARK [3][-]{subsubsection.32.1.1}{Beispiel}{subsection.32.1}% 138
\BOOKMARK [2][-]{subsection.32.2}{Gew\344hrleistung von Portabilit\344t}{section.32}% 139
\BOOKMARK [2][-]{subsection.32.3}{Wie setzt der Compiler ein typedef um?}{section.32}% 140
\BOOKMARK [1][-]{section.33}{Initialisierung}{part.5}% 141
\BOOKMARK [1][-]{section.34}{Type-Cast \(Typumwandlungen\)}{part.5}% 142
\BOOKMARK [2][-]{subsection.34.1}{Typumwandlungen im Allgemeinen}{section.34}% 143
\BOOKMARK [2][-]{subsection.34.2}{Implizite Typumwandlung}{section.34}% 144
\BOOKMARK [2][-]{subsection.34.3}{Explizite Typumwandlung}{section.34}% 145
\BOOKMARK [3][-]{subsubsection.34.3.1}{Explizite Typumwandlung \0431, 2: C-Stil und Funktionsstil}{subsection.34.3}% 146
\BOOKMARK [3][-]{subsubsection.34.3.2}{Typumwandlung mit C-Stil und Funktionsstil}{subsection.34.3}% 147
\BOOKMARK [3][-]{subsubsection.34.3.3}{Explizite Typumwandlung \0433: const\137cast}{subsection.34.3}% 148
\BOOKMARK [3][-]{subsubsection.34.3.4}{Explizite Typumwandlung \0434: static\137cast}{subsection.34.3}% 149
\BOOKMARK [3][-]{subsubsection.34.3.5}{Explizite Typumwandlung \0435: dynamic\137cast}{subsection.34.3}% 150
\BOOKMARK [3][-]{subsubsection.34.3.6}{Explizite Typumwandlung \0436: reinterpret\137cast}{subsection.34.3}% 151
\BOOKMARK [0][-]{part.6}{VI Module und Datenkapseln}{}% 152
\BOOKMARK [1][-]{section.35}{Modul \(Unit\)}{part.6}% 153
\BOOKMARK [2][-]{subsection.35.1}{Nomenklatur: Modul vs. Unit}{section.35}% 154
\BOOKMARK [2][-]{subsection.35.2}{Ziele der Modularisierung}{section.35}% 155
\BOOKMARK [2][-]{subsection.35.3}{Eigenschaften einer Unit \(eines Moduls\)}{section.35}% 156
\BOOKMARK [2][-]{subsection.35.4}{Bestandteile eine C++-Programms}{section.35}% 157
\BOOKMARK [2][-]{subsection.35.5}{Unitkonzept}{section.35}% 158
\BOOKMARK [2][-]{subsection.35.6}{Geheimnisprinpzip \(Information Hiding\)}{section.35}% 159
\BOOKMARK [3][-]{subsubsection.35.6.1}{Information Hiding}{subsection.35.6}% 160
\BOOKMARK [3][-]{subsubsection.35.6.2}{Konzept der Datenkapsel}{subsection.35.6}% 161
\BOOKMARK [3][-]{subsubsection.35.6.3}{Beispiel f\374r Datenzugriff bei Datenkapsel}{subsection.35.6}% 162
\BOOKMARK [3][-]{subsubsection.35.6.4}{Beispiel f\374r Unit Rechteck \(ohne Datenkapsel\)}{subsection.35.6}% 163
\BOOKMARK [3][-]{subsubsection.35.6.5}{Beispiel f\374r Unit Rechteck: Verbesserung \0431}{subsection.35.6}% 164
\BOOKMARK [3][-]{subsubsection.35.6.6}{Beispiel f\374r Unit Rechteck: Verbesserung \0432}{subsection.35.6}% 165
\BOOKMARK [2][-]{subsection.35.7}{Unit nutzen}{section.35}% 166
\BOOKMARK [2][-]{subsection.35.8}{Unit-Schnittstelle definieren \(in Headerdatei\)}{section.35}% 167
\BOOKMARK [2][-]{subsection.35.9}{Deklarationsreihenfolge in der Headerdatei \(*.h\)}{section.35}% 168
\BOOKMARK [2][-]{subsection.35.10}{Reihenfolge in der Implementierungsdatei \(*.cpp\)}{section.35}% 169
\BOOKMARK [2][-]{subsection.35.11}{\043include-Konzept}{section.35}% 170
\BOOKMARK [2][-]{subsection.35.12}{Unit compilieren}{section.35}% 171
\BOOKMARK [2][-]{subsection.35.13}{Units linken}{section.35}% 172
\BOOKMARK [2][-]{subsection.35.14}{Buildprozess}{section.35}% 173
\BOOKMARK [2][-]{subsection.35.15}{Make-Tool}{section.35}% 174
\BOOKMARK [3][-]{subsubsection.35.15.1}{Abh\344ngigkeiten zwischen Dateien}{subsection.35.15}% 175
\BOOKMARK [3][-]{subsubsection.35.15.2}{make-File}{subsection.35.15}% 176
\BOOKMARK [3][-]{subsubsection.35.15.3}{Beispiel: makefile}{subsection.35.15}% 177
\BOOKMARK [0][-]{part.7}{VII Eclipse IDE}{}% 178
\BOOKMARK [1][-]{section.36}{Eclipse}{part.7}% 179
\BOOKMARK [2][-]{subsection.36.1}{Workspace}{section.36}% 180
\BOOKMARK [2][-]{subsection.36.2}{Ressourcen \(Resources\)}{section.36}% 181
\BOOKMARK [2][-]{subsection.36.3}{Project}{section.36}% 182
\BOOKMARK [2][-]{subsection.36.4}{Debugger}{section.36}% 183
\BOOKMARK [3][-]{subsubsection.36.4.1}{Testen und Debugging}{subsection.36.4}% 184
\BOOKMARK [3][-]{subsubsection.36.4.2}{Funktionen eines Debuggers}{subsection.36.4}% 185
\BOOKMARK [3][-]{subsubsection.36.4.3}{Assertions \(Zusicherungen\)}{subsection.36.4}% 186
\BOOKMARK [3][-]{subsubsection.36.4.4}{Zu beachten bei Assertions}{subsection.36.4}% 187
\BOOKMARK [0][-]{part.8}{VIII Klassen}{}% 188
\BOOKMARK [1][-]{section.37}{Beispielprojekt Stack}{part.8}% 189
\BOOKMARK [2][-]{subsection.37.1}{Stack}{section.37}% 190
\BOOKMARK [3][-]{subsubsection.37.1.1}{Stack - Operationen}{subsection.37.1}% 191
\BOOKMARK [3][-]{subsubsection.37.1.2}{Demo: Codebeispiel f\374r Stack \(Stack\137Datenkapsel\)}{subsection.37.1}% 192
\BOOKMARK [2][-]{subsection.37.2}{Queue}{section.37}% 193
\BOOKMARK [3][-]{subsubsection.37.2.1}{Queue - Operationen}{subsection.37.2}% 194
\BOOKMARK [1][-]{section.38}{Objektorientierte Programmierung}{part.8}% 195
\BOOKMARK [2][-]{subsection.38.1}{Modell und Realit\344t}{section.38}% 196
\BOOKMARK [2][-]{subsection.38.2}{Zu \(subjektiven\) Sichtweise des Betrachters}{section.38}% 197
\BOOKMARK [2][-]{subsection.38.3}{Prozedurale vs. Objektorientierte Sicht}{section.38}% 198
\BOOKMARK [1][-]{section.39}{Unified Modeling Language \(UML\)}{part.8}% 199
\BOOKMARK [2][-]{subsection.39.1}{Entstehung der UML}{section.39}% 200
\BOOKMARK [2][-]{subsection.39.2}{Was ist UML?}{section.39}% 201
\BOOKMARK [2][-]{subsection.39.3}{Klassenbegriff}{section.39}% 202
\BOOKMARK [2][-]{subsection.39.4}{UML-Notation der Klasse}{section.39}% 203
\BOOKMARK [2][-]{subsection.39.5}{Klasse definieren und Objekte anlegen: Syntax}{section.39}% 204
\BOOKMARK [1][-]{section.40}{Zugriffsschutz bei Klassen}{part.8}% 205
\BOOKMARK [2][-]{subsection.40.1}{Zugriffsschutz mit public, protected und private}{section.40}% 206
\BOOKMARK [3][-]{subsubsection.40.1.1}{\334blicher Aufbau einer Klassenschnittstelle}{subsection.40.1}% 207
\BOOKMARK [2][-]{subsection.40.2}{Operationen einer Klasse}{section.40}% 208
\BOOKMARK [2][-]{subsection.40.3}{Information Hiding}{section.40}% 209
\BOOKMARK [1][-]{section.41}{Beispiel einer Klasse: Rechteck \(Rectangle\)}{part.8}% 210
\BOOKMARK [2][-]{subsection.41.1}{Klassendeklaration}{section.41}% 211
\BOOKMARK [2][-]{subsection.41.2}{Klassendefinition}{section.41}% 212
\BOOKMARK [2][-]{subsection.41.3}{Klassendefinition direkt}{section.41}% 213
\BOOKMARK [2][-]{subsection.41.4}{Reprise: Projekt Stack}{section.41}% 214
\BOOKMARK [2][-]{subsection.41.5}{Klassenschnittstelle}{section.41}% 215
\BOOKMARK [1][-]{section.42}{Elementfunktionen}{part.8}% 216
\BOOKMARK [2][-]{subsection.42.1}{Klassifizierung von Elementfunktionen}{section.42}% 217
\BOOKMARK [2][-]{subsection.42.2}{inline-Elementfunktionen}{section.42}% 218
\BOOKMARK [2][-]{subsection.42.3}{Projekt Stack}{section.42}% 219
\BOOKMARK [2][-]{subsection.42.4}{const - Elementfunktionen}{section.42}% 220
\BOOKMARK [3][-]{subsubsection.42.4.1}{const - Elementfunktionen: Schlussfolgerung}{subsection.42.4}% 221
\BOOKMARK [2][-]{subsection.42.5}{Projekt Stack}{section.42}% 222
\BOOKMARK [2][-]{subsection.42.6}{mutable-Attribut}{section.42}% 223
\BOOKMARK [2][-]{subsection.42.7}{Projekt Stack}{section.42}% 224
\BOOKMARK [1][-]{section.43}{Konstruktoren/Destruktoren}{part.8}% 225
\BOOKMARK [2][-]{subsection.43.1}{this-Pointer}{section.43}% 226
\BOOKMARK [2][-]{subsection.43.2}{friend-Elemente}{section.43}% 227
\BOOKMARK [2][-]{subsection.43.3}{static-Klassenelemente \(Kap.11.5\)}{section.43}% 228
\BOOKMARK [3][-]{subsubsection.43.3.1}{Syntax}{subsection.43.3}% 229
\BOOKMARK [2][-]{subsection.43.4}{Konstruktor \(Constructor, Ctor\)}{section.43}% 230
\BOOKMARK [3][-]{subsubsection.43.4.1}{Aufruf}{subsection.43.4}% 231
\BOOKMARK [3][-]{subsubsection.43.4.2}{Beispiel: Klasse TString \(nach Lippman\)}{subsection.43.4}% 232
\BOOKMARK [3][-]{subsubsection.43.4.3}{Implementation von TString::TString\(\)}{subsection.43.4}% 233
\BOOKMARK [3][-]{subsubsection.43.4.4}{\334berladen von Konstruktoren}{subsection.43.4}% 234
\BOOKMARK [3][-]{subsubsection.43.4.5}{Erweiterung der Klasse TString}{subsection.43.4}% 235
\BOOKMARK [3][-]{subsubsection.43.4.6}{Konstruktoren und Function Casts}{subsection.43.4}% 236
\BOOKMARK [3][-]{subsubsection.43.4.7}{Erweiterung der Klasse TString 2}{subsection.43.4}% 237
\BOOKMARK [3][-]{subsubsection.43.4.8}{Copy-Konstruktor}{subsection.43.4}% 238
\BOOKMARK [3][-]{subsubsection.43.4.9}{Copy-Konstruktor wird automatisch aufgerufen, wenn...}{subsection.43.4}% 239
\BOOKMARK [3][-]{subsubsection.43.4.10}{Erweiterung der Klasse TString 3}{subsection.43.4}% 240
\BOOKMARK [3][-]{subsubsection.43.4.11}{Shallow Copy vs. Deep Copy}{subsection.43.4}% 241
\BOOKMARK [3][-]{subsubsection.43.4.12}{Copy-Konstruktor der Klasse TString}{subsection.43.4}% 242
\BOOKMARK [2][-]{subsection.43.5}{Destruktor \(Destructor, Dtor\)}{section.43}% 243
\BOOKMARK [3][-]{subsubsection.43.5.1}{Eigenschaften des Destruktors}{subsection.43.5}% 244
\BOOKMARK [3][-]{subsubsection.43.5.2}{Erweiterung der Klasse TString 4}{subsection.43.5}% 245
\BOOKMARK [3][-]{subsubsection.43.5.3}{Implementation des Destruktors}{subsection.43.5}% 246
\BOOKMARK [3][-]{subsubsection.43.5.4}{Schnittstelle der Klasse TString}{subsection.43.5}% 247
\BOOKMARK [3][-]{subsubsection.43.5.5}{Demo: Klasse Stack}{subsection.43.5}% 248
\BOOKMARK [1][-]{section.44}{Handhabung von Klassen und Objekten}{part.8}% 249
\BOOKMARK [2][-]{subsection.44.1}{Repetition}{section.44}% 250
\BOOKMARK [2][-]{subsection.44.2}{Welche Ctors werden bei folgenden Anweisungen aufgerufen?}{section.44}% 251
\BOOKMARK [2][-]{subsection.44.3}{Automatisch generierte Elementfunktionen \(11.7.4\)}{section.44}% 252
\BOOKMARK [2][-]{subsection.44.4}{Kanonische Form von Klassen \(11.7.5\)}{section.44}% 253
\BOOKMARK [2][-]{subsection.44.5}{Benutzerdefinierte Typumwandlungen: Problemstellung \046 L\366sung}{section.44}% 254
\BOOKMARK [2][-]{subsection.44.6}{Typumwandlung mit Konstruktor}{section.44}% 255
\BOOKMARK [2][-]{subsection.44.7}{Weiterf\374hrende Themen}{section.44}% 256
\BOOKMARK [3][-]{subsubsection.44.7.1}{Zeiger auf Klassenelemente}{subsection.44.7}% 257
\BOOKMARK [2][-]{subsection.44.8}{Unions \(Varianten\)}{section.44}% 258
\BOOKMARK [3][-]{subsubsection.44.8.1}{Eigenschaften einer Union}{subsection.44.8}% 259
\BOOKMARK [3][-]{subsubsection.44.8.2}{Definition von Uniontypen und Unionvariablen}{subsection.44.8}% 260
\BOOKMARK [3][-]{subsubsection.44.8.3}{Beispiel: Definition einer Union}{subsection.44.8}% 261
\BOOKMARK [2][-]{subsection.44.9}{Bitfelder}{section.44}% 262
\BOOKMARK [3][-]{subsubsection.44.9.1}{Eigenschaften von Bitfeldern}{subsection.44.9}% 263
\BOOKMARK [3][-]{subsubsection.44.9.2}{Definition von von Bitfeldern}{subsection.44.9}% 264
\BOOKMARK [3][-]{subsubsection.44.9.3}{Bitfelder: Folgerungen}{subsection.44.9}% 265
\BOOKMARK [2][-]{subsection.44.10}{Demo: Klasse Date}{section.44}% 266
\BOOKMARK [0][-]{part.9}{IX Vererbung}{}% 267
\BOOKMARK [1][-]{section.45}{Motivation}{part.9}% 268
\BOOKMARK [1][-]{section.46}{Artikel als Gemeinsamkeit von Buch und CD}{part.9}% 269
\BOOKMARK [1][-]{section.47}{Grundkonzept}{part.9}% 270
\BOOKMARK [1][-]{section.48}{Einsatz der Vererbung}{part.9}% 271
\BOOKMARK [1][-]{section.49}{UML-Notation}{part.9}% 272
\BOOKMARK [2][-]{subsection.49.1}{\357st einBeziehung}{section.49}% 273
\BOOKMARK [1][-]{section.50}{Beispiel: Vererbungshierarchie Lebewesen}{part.9}% 274
\BOOKMARK [2][-]{subsection.50.1}{C++-Syntax}{section.50}% 275
\BOOKMARK [2][-]{subsection.50.2}{Zugriff auf Elemente der Basisklasse}{section.50}% 276
\BOOKMARK [1][-]{section.51}{Spezifikation von Basisklassen}{part.9}% 277
\BOOKMARK [1][-]{section.52}{Beispiel: ComicCharacter \(Comics01\)}{part.9}% 278
\BOOKMARK [1][-]{section.53}{Einsatz von protected bei Klassenelementen}{part.9}% 279
\BOOKMARK [1][-]{section.54}{Objektgr\366sse bei der Vererbung}{part.9}% 280
\BOOKMARK [1][-]{section.55}{Schlechter \(falscher\) Einsatz von Vererbung}{part.9}% 281
\BOOKMARK [1][-]{section.56}{Substitutionsprinzip}{part.9}% 282
\BOOKMARK [0][-]{part.10}{X Polymorphismus}{}% 283
\BOOKMARK [1][-]{section.57}{Static vs. Dynamic Binding}{part.10}% 284
\BOOKMARK [2][-]{subsection.57.1}{Dynamic Binding}{section.57}% 285
\BOOKMARK [3][-]{subsubsection.57.1.1}{Beispiel: Zeichnen von geometrischen Figuren}{subsection.57.1}% 286
\BOOKMARK [2][-]{subsection.57.2}{Statischer vs. dynamischer Datentyp}{section.57}% 287
\BOOKMARK [2][-]{subsection.57.3}{Aufruf von virtuellen Elementfunktionen}{section.57}% 288
\BOOKMARK [3][-]{subsubsection.57.3.1}{Statischer Aufruf von virtuellen Elementfunktionen}{subsection.57.3}% 289
\BOOKMARK [3][-]{subsubsection.57.3.2}{Dynamischer Aufruf von virtuellen Elementfunktionen}{subsection.57.3}% 290
\BOOKMARK [2][-]{subsection.57.4}{Polymorphe Klassen \(Virtuelle Klassen\)}{section.57}% 291
\BOOKMARK [3][-]{subsubsection.57.4.1}{Repr\344sentation virtueller Objekte im Speicher}{subsection.57.4}% 292
\BOOKMARK [1][-]{section.58}{Abstrakte Klassen}{part.10}% 293
\BOOKMARK [2][-]{subsection.58.1}{Anwendungen von abstrakten Klassen \(Beispiele\)}{section.58}% 294
\BOOKMARK [1][-]{section.59}{Mehrfachvererbung \(Multiple Inheritance, MI\)}{part.10}% 295
\BOOKMARK [2][-]{subsection.59.1}{Virtuelle Basisklassen}{section.59}% 296
\BOOKMARK [1][-]{section.60}{Laufzeit-Typinformationen \(Run-Time Type Information, RTTI\)}{part.10}% 297
\BOOKMARK [2][-]{subsection.60.1}{Operator dynamic\137cast}{section.60}% 298
\BOOKMARK [2][-]{subsection.60.2}{Operator typeid}{section.60}% 299
\BOOKMARK [0][-]{part.11}{XI \334berladen von Operatoren \(Operator overloading\)}{}% 300
\BOOKMARK [1][-]{section.61}{Operator overloading in C++}{part.11}% 301
\BOOKMARK [2][-]{subsection.61.1}{Operatorfunktion}{section.61}% 302
\BOOKMARK [2][-]{subsection.61.2}{Randbedingungen zu Operator overloading}{section.61}% 303
\BOOKMARK [2][-]{subsection.61.3}{Umsetzungsvarianten f\374r Operator overloading}{section.61}% 304
\BOOKMARK [3][-]{subsubsection.61.3.1}{Beispiel}{subsection.61.3}% 305
\BOOKMARK [3][-]{subsubsection.61.3.2}{Zuweisungsoperator =}{subsection.61.3}% 306
\BOOKMARK [3][-]{subsubsection.61.3.3}{Indexoperator []}{subsection.61.3}% 307
\BOOKMARK [3][-]{subsubsection.61.3.4}{Beispiel Klasse TString}{subsection.61.3}% 308
\BOOKMARK [3][-]{subsubsection.61.3.5}{Eigenen Zuweisungsoperator definieren}{subsection.61.3}% 309
\BOOKMARK [3][-]{subsubsection.61.3.6}{Zur Erinnerung: Kanonische Form einer Klasse}{subsection.61.3}% 310
\BOOKMARK [2][-]{subsection.61.4}{Streamkonzept}{section.61}% 311
\BOOKMARK [3][-]{subsubsection.61.4.1}{Ausgabe: Klasse ostream}{subsection.61.4}% 312
\BOOKMARK [3][-]{subsubsection.61.4.2}{Operator << \374berschreiben}{subsection.61.4}% 313
\BOOKMARK [3][-]{subsubsection.61.4.3}{Eingabe: Klasse istream}{subsection.61.4}% 314
\BOOKMARK [3][-]{subsubsection.61.4.4}{Operator >> \374berschreiben}{subsection.61.4}% 315
\BOOKMARK [0][-]{part.12}{XII Templates}{}% 316
\BOOKMARK [1][-]{section.62}{Generische Programmierung mit Templates \(Schablonen\)}{part.12}% 317
\BOOKMARK [2][-]{subsection.62.1}{Motivation f\374r Templates}{section.62}% 318
\BOOKMARK [2][-]{subsection.62.2}{L\366sung mit bekannten Techniken}{section.62}% 319
\BOOKMARK [2][-]{subsection.62.3}{Generische Programmierung mit Templates}{section.62}% 320
\BOOKMARK [1][-]{section.63}{Funktions-Templates}{part.12}% 321
\BOOKMARK [2][-]{subsection.63.1}{Syntax f\374r Funktions-Templates}{section.63}% 322
\BOOKMARK [2][-]{subsection.63.2}{Beispiel \(aus Prata\): Zwei Werte vertauschen}{section.63}% 323
\BOOKMARK [2][-]{subsection.63.3}{inline bei Templates}{section.63}% 324
\BOOKMARK [2][-]{subsection.63.4}{Beispiel: kleinstes Element finden}{section.63}% 325
\BOOKMARK [2][-]{subsection.63.5}{Auspr\344gung von Funktions-Templates}{section.63}% 326
\BOOKMARK [2][-]{subsection.63.6}{Explizite Qualifizierung von Funktions-Templates}{section.63}% 327
\BOOKMARK [2][-]{subsection.63.7}{\334berladen von Funktions-Templates}{section.63}% 328
\BOOKMARK [1][-]{section.64}{Klassen-Templates}{part.12}% 329
\BOOKMARK [2][-]{subsection.64.1}{Definition: Klassen-Template}{section.64}% 330
\BOOKMARK [2][-]{subsection.64.2}{Syntax f\374r Klassen-Templates}{section.64}% 331
\BOOKMARK [3][-]{subsubsection.64.2.1}{Beispiel zu Klassen-Template: Deklaration}{subsection.64.2}% 332
\BOOKMARK [3][-]{subsubsection.64.2.2}{Beispiel zu Klassen-Template: Definition}{subsection.64.2}% 333
\BOOKMARK [3][-]{subsubsection.64.2.3}{Beispiel zu Klassen-Template: Nutzung \(Auspr\344gung\)}{subsection.64.2}% 334
\BOOKMARK [2][-]{subsection.64.3}{Bemerkungen}{section.64}% 335
\BOOKMARK [2][-]{subsection.64.4}{Explizite Auspr\344gung von Klassen-Templates}{section.64}% 336
\BOOKMARK [2][-]{subsection.64.5}{Klassen-Templates und getrennte \334bersetzung: export}{section.64}% 337
\BOOKMARK [2][-]{subsection.64.6}{Klassen-Templates und getrennte \334bersetzung}{section.64}% 338
\BOOKMARK [3][-]{subsubsection.64.6.1}{File-Organisation \0431 bei Klassen-Templates}{subsection.64.6}% 339
\BOOKMARK [3][-]{subsubsection.64.6.2}{Ausschliessen eines cpp-Files von Compilierung in Eclipse}{subsection.64.6}% 340
\BOOKMARK [3][-]{subsubsection.64.6.3}{File-Organisation \0432 bei Klassen-Templates}{subsection.64.6}% 341
\BOOKMARK [2][-]{subsection.64.7}{Fazit}{section.64}% 342
\BOOKMARK [0][-]{part.13}{XIII Exceptions \(\214Ausnahmen\215\)}{}% 343
\BOOKMARK [1][-]{section.65}{Exception vs. Error}{part.13}% 344
\BOOKMARK [1][-]{section.66}{M\366gliche Reaktionen auf Ausnahmen}{part.13}% 345
\BOOKMARK [1][-]{section.67}{Exceptioncodes als R\374ckgabewert}{part.13}% 346
\BOOKMARK [1][-]{section.68}{Exceptioncodes als Referenzparameter}{part.13}% 347
\BOOKMARK [1][-]{section.69}{Globaler Exceptioncode}{part.13}% 348
\BOOKMARK [1][-]{section.70}{Wo sollen Exceptions behandelt werden?}{part.13}% 349
\BOOKMARK [2][-]{subsection.70.1}{Beispiel: \334bertragungssystem}{section.70}% 350
\BOOKMARK [1][-]{section.71}{Ziel f\374r Exception Handling}{part.13}% 351
\BOOKMARK [1][-]{section.72}{Exception Handling in C++}{part.13}% 352
\BOOKMARK [2][-]{subsection.72.1}{Exception Handling in C++: Syntax}{section.72}% 353
\BOOKMARK [2][-]{subsection.72.2}{Ausl\366sen \(Werfen\) von Ausnahmen}{section.72}% 354
\BOOKMARK [3][-]{subsubsection.72.2.1}{Beispiel f\374r Exception Handling: un\374bliche Variante}{subsection.72.2}% 355
\BOOKMARK [2][-]{subsection.72.3}{Vordefinierte Ausnahmeklassen}{section.72}% 356
\BOOKMARK [2][-]{subsection.72.4}{Exception-Hierarchie in C++}{section.72}% 357
\BOOKMARK [2][-]{subsection.72.5}{Laufzeit- vs. Logische \214Fehler\215}{section.72}% 358
\BOOKMARK [2][-]{subsection.72.6}{Exceptions und ihre Header-Dateien}{section.72}% 359
\BOOKMARK [2][-]{subsection.72.7}{Exception Handler}{section.72}% 360
\BOOKMARK [3][-]{subsubsection.72.7.1}{Handler mit beliebigne Exceptions ohne Hierarchie}{subsection.72.7}% 361
\BOOKMARK [3][-]{subsubsection.72.7.2}{Handler mit System-Exceptions}{subsection.72.7}% 362
\BOOKMARK [3][-]{subsubsection.72.7.3}{Handler mit schlechter Reihenfolge}{subsection.72.7}% 363
\BOOKMARK [2][-]{subsection.72.8}{Exception Handler 2}{section.72}% 364
\BOOKMARK [2][-]{subsection.72.9}{Exception Propagation}{section.72}% 365
\BOOKMARK [2][-]{subsection.72.10}{Exception Specification}{section.72}% 366
\BOOKMARK [3][-]{subsubsection.72.10.1}{Exception Specification: Beispiele}{subsection.72.10}% 367
\BOOKMARK [3][-]{subsubsection.72.10.2}{Exception Handling in der Praxis}{subsection.72.10}% 368
\BOOKMARK [3][-]{subsubsection.72.10.3}{Throw exceptions by value, catch them by const reference}{subsection.72.10}% 369
\BOOKMARK [3][-]{subsubsection.72.10.4}{Handling von System Exceptions}{subsection.72.10}% 370
\BOOKMARK [3][-]{subsubsection.72.10.5}{Handling-Strategie von System Exceptions bei verschiedenen Programmiersprachen}{subsection.72.10}% 371
\BOOKMARK [3][-]{subsubsection.72.10.6}{Betreibt meine Umgebung Exception Mapping?}{subsection.72.10}% 372
\BOOKMARK [0][-]{part.14}{XIV Preprocessor}{}% 373
\BOOKMARK [1][-]{section.73}{Eigenschaften des Preprocessors}{part.14}% 374
\BOOKMARK [1][-]{section.74}{Preprocessor-Direktiven und Bedingungsanweisungen}{part.14}% 375
\BOOKMARK [2][-]{subsection.74.1}{\043define}{section.74}% 376
\BOOKMARK [2][-]{subsection.74.2}{\043undef}{section.74}% 377
\BOOKMARK [2][-]{subsection.74.3}{\043include}{section.74}% 378
\BOOKMARK [2][-]{subsection.74.4}{\043line}{section.74}% 379
\BOOKMARK [2][-]{subsection.74.5}{\043error}{section.74}% 380
\BOOKMARK [2][-]{subsection.74.6}{\043pragma}{section.74}% 381
\BOOKMARK [2][-]{subsection.74.7}{Bedingungsanweisungen}{section.74}% 382
\BOOKMARK [3][-]{subsubsection.74.7.1}{Beispiele f\374r Bedingungsanweisungen}{subsection.74.7}% 383
\BOOKMARK [2][-]{subsection.74.8}{Weitere Features des Preprocessors}{section.74}% 384
\BOOKMARK [2][-]{subsection.74.9}{Kritische W\374rdigung des Preprocessors}{section.74}% 385
