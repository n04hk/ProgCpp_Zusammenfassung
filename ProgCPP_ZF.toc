\select@language {ngerman}
\contentsline {part}{I\hspace {1em}Einf\IeC {\"u}hrung}{10}{part.1}
\contentsline {section}{\numberline {1}Charakteristiken von C++}{10}{section.1}
\contentsline {section}{\numberline {2}Entstehung von C++}{10}{section.2}
\contentsline {section}{\numberline {3}Welches C++?}{10}{section.3}
\contentsline {section}{\numberline {4}C++-Unterst\IeC {\"u}tzung von Texas Instruments (TI)}{10}{section.4}
\contentsline {section}{\numberline {5}Hello World!}{11}{section.5}
\contentsline {section}{\numberline {6}C++-Compiler (noch nicht Eclipse)}{11}{section.6}
\contentsline {section}{\numberline {7}Lexikalische Elemente von C++}{11}{section.7}
\contentsline {section}{\numberline {8}Styleguide: Bezeichner (\raisebox {-0.9ex}{\~{ }}Namen)}{11}{section.8}
\contentsline {section}{\numberline {9}Typkonzept}{12}{section.9}
\contentsline {subsection}{\numberline {9.1}Datentypen}{12}{subsection.9.1}
\contentsline {subsection}{\numberline {9.2}{\#}define}{12}{subsection.9.2}
\contentsline {section}{\numberline {10}Ausdr\IeC {\"u}cke und Operatoren}{12}{section.10}
\contentsline {section}{\numberline {11}Anweisungen}{12}{section.11}
\contentsline {section}{\numberline {12}Streams}{12}{section.12}
\contentsline {subsection}{\numberline {12.1}Streamkonzept}{12}{subsection.12.1}
\contentsline {subsection}{\numberline {12.2}Einsatz von Streams}{12}{subsection.12.2}
\contentsline {subsection}{\numberline {12.3}Ausgabe: Klasse ostream}{13}{subsection.12.3}
\contentsline {subsection}{\numberline {12.4}Eingabe: Klasse istream}{13}{subsection.12.4}
\contentsline {subsection}{\numberline {12.5}Formatierte Ein- und Ausgabe}{13}{subsection.12.5}
\contentsline {subsubsection}{\numberline {12.5.1}Format-Flags um \IeC {\"U}berblick {(unvollst\IeC {\"a}ndig)}}{14}{subsubsection.12.5.1}
\contentsline {part}{II\hspace {1em}Funktionen}{15}{part.2}
\contentsline {section}{\numberline {13}Grundlegendes}{15}{section.13}
\contentsline {subsection}{\numberline {13.1}Synonyme f\IeC {\"u}r Funktionen}{15}{subsection.13.1}
\contentsline {subsection}{\numberline {13.2}Aufgabe einer Funktion}{15}{subsection.13.2}
\contentsline {subsection}{\numberline {13.3}Funktionen (Vergleich zu C)}{15}{subsection.13.3}
\contentsline {subsection}{\numberline {13.4}Definition von Funktionen}{15}{subsection.13.4}
\contentsline {subsection}{\numberline {13.5}Deklaration von Funktionen (Funktionsprototypen)}{16}{subsection.13.5}
\contentsline {subsection}{\numberline {13.6}Kosten einer Funktion}{16}{subsection.13.6}
\contentsline {section}{\numberline {14}C-Makro}{16}{section.14}
\contentsline {subsection}{\numberline {14.1}C-Makro mit {\#define}}{16}{subsection.14.1}
\contentsline {subsection}{\numberline {14.2}Beispiel mit C-Makro: Maximum zweier int-Werte}{16}{subsection.14.2}
\contentsline {subsubsection}{\numberline {14.2.1}Was passiert wirklich?}{17}{subsubsection.14.2.1}
\contentsline {section}{\numberline {15}inline-Funktionen}{17}{section.15}
\contentsline {subsection}{\numberline {15.1}Grundlegendes}{17}{subsection.15.1}
\contentsline {subsection}{\numberline {15.2}Beispiel mit inline-Code: Maximum zweier int-Werte}{17}{subsection.15.2}
\contentsline {section}{\numberline {16}Grunds\IeC {\"a}tze f\IeC {\"u}r Optimierungen}{17}{section.16}
\contentsline {section}{\numberline {17}default-Argumente}{17}{section.17}
\contentsline {subsection}{\numberline {17.1}Vorbelegte Parameter (default-Argumente)}{17}{subsection.17.1}
\contentsline {subsubsection}{\numberline {17.1.1}Beispiel: default-Argumente}{18}{subsubsection.17.1.1}
\contentsline {subsection}{\numberline {17.2}Nutzen von default-Argumenten}{18}{subsection.17.2}
\contentsline {section}{\numberline {18}Overloading}{18}{section.18}
\contentsline {subsection}{\numberline {18.1}\IeC {\"U}berladen von Funktionen (overloading)}{18}{subsection.18.1}
\contentsline {subsection}{\numberline {18.2}Overloading in C++}{18}{subsection.18.2}
\contentsline {subsubsection}{\numberline {18.2.1}Deklaration von \IeC {\"u}berladenen Funktionen: Regeln}{19}{subsubsection.18.2.1}
\contentsline {subsubsection}{\numberline {18.2.2}Funktionen sollen nur dann \IeC {\"u}berladen werden, wenn ...}{19}{subsubsection.18.2.2}
\contentsline {section}{\numberline {19}default-Parameter vs. Overloading}{19}{section.19}
\contentsline {part}{III\hspace {1em}Pointer und Referenzen}{20}{part.3}
\contentsline {section}{\numberline {20}H\IeC {\"o}here und strukturierte Datentypen}{20}{section.20}
\contentsline {subsection}{\numberline {20.1}H\IeC {\"o}here Datentypen}{20}{subsection.20.1}
\contentsline {subsection}{\numberline {20.2}Strukturierte Datentypen}{20}{subsection.20.2}
\contentsline {section}{\numberline {21}Pointer}{20}{section.21}
\contentsline {subsection}{\numberline {21.1}Adresse}{20}{subsection.21.1}
\contentsline {subsection}{\numberline {21.2}Standarddarstellung von Pointern}{20}{subsection.21.2}
\contentsline {subsection}{\numberline {21.3}Pointer und Datentyp}{20}{subsection.21.3}
\contentsline {subsection}{\numberline {21.4}Definition einer Pointervariablen}{20}{subsection.21.4}
\contentsline {subsubsection}{\numberline {21.4.1}Initialisierung mit Null-Pointer}{21}{subsubsection.21.4.1}
\contentsline {subsubsection}{\numberline {21.4.2}Der Adressoperator \& \textbf {(Referenzierung)}}{21}{subsubsection.21.4.2}
\contentsline {subsubsection}{\numberline {21.4.3}Kopieren von Adressen}{21}{subsubsection.21.4.3}
\contentsline {subsubsection}{\numberline {21.4.4}Der Inhaltsoperator * \textbf {(Dereferenzierung)}}{22}{subsubsection.21.4.4}
\contentsline {subsubsection}{\numberline {21.4.5}const bei Pointern: Vorsicht}{22}{subsubsection.21.4.5}
\contentsline {subsubsection}{\numberline {21.4.6}void-Pointer}{22}{subsubsection.21.4.6}
\contentsline {subsubsection}{\numberline {21.4.7}Pointer auf Funktionen}{23}{subsubsection.21.4.7}
\contentsline {subsubsection}{\numberline {21.4.8}Interruptvektortabelle: Tabelle von Funktionspointern}{23}{subsubsection.21.4.8}
\contentsline {subsubsection}{\numberline {21.4.9}Umsetzung von Funktionspointern in C/C++}{23}{subsubsection.21.4.9}
\contentsline {subsubsection}{\numberline {21.4.10}Beispiel f\IeC {\"u}r Funktionspointer}{24}{subsubsection.21.4.10}
\contentsline {section}{\numberline {22}Referenzen}{24}{section.22}
\contentsline {subsection}{\numberline {22.1}Syntax}{24}{subsection.22.1}
\contentsline {subsection}{\numberline {22.2}Einsatz}{25}{subsection.22.2}
\contentsline {section}{\numberline {23}Pointer und Referenzen auf lokale Variablen}{25}{section.23}
\contentsline {section}{\numberline {24}Zeiger und Referenzen als Parameter und R\IeC {\"u}ckgabewerte}{25}{section.24}
\contentsline {subsection}{\numberline {24.1}Call by Value vs. Call by Reference}{25}{subsection.24.1}
\contentsline {subsubsection}{\numberline {24.1.1}3 Beispiele}{25}{subsubsection.24.1.1}
\contentsline {subsection}{\numberline {24.2}Call by reference: wann einsetzen?}{25}{subsection.24.2}
\contentsline {subsection}{\numberline {24.3}Merke}{26}{subsection.24.3}
\contentsline {part}{IV\hspace {1em}Arrays, Dynamische Speicherverwaltung}{27}{part.4}
\contentsline {section}{\numberline {25}Arrays}{27}{section.25}
\contentsline {subsection}{\numberline {25.1}Arrays: Vektoren}{27}{subsection.25.1}
\contentsline {subsection}{\numberline {25.2}Der Array (Feld, Vektor)}{27}{subsection.25.2}
\contentsline {subsubsection}{\numberline {25.2.1}Zugriff auf ein Arrayelement}{27}{subsubsection.25.2.1}
\contentsline {subsection}{\numberline {25.3}Arrays und Pointer}{28}{subsection.25.3}
\contentsline {subsubsection}{\numberline {25.3.1}Pro Memoria: Eindimensionales Array (Vektor)}{28}{subsubsection.25.3.1}
\contentsline {subsection}{\numberline {25.4}\IeC {\"A}quivalenz von Array- und Pointernotation}{28}{subsection.25.4}
\contentsline {subsection}{\numberline {25.5}Vergleichen von Arrays}{28}{subsection.25.5}
\contentsline {subsection}{\numberline {25.6}Der Arrayname ist ein nicht modifizierbarer L-Wert}{28}{subsection.25.6}
\contentsline {subsection}{\numberline {25.7}Automatische Initialisierung von Arrays}{28}{subsection.25.7}
\contentsline {subsection}{\numberline {25.8}Explizite Initialisierung von Arrays}{28}{subsection.25.8}
\contentsline {subsubsection}{\numberline {25.8.1}Beispiel}{29}{subsubsection.25.8.1}
\contentsline {subsubsection}{\numberline {25.8.2}Goodies f\IeC {\"u}r die explizite Initialisierung}{29}{subsubsection.25.8.2}
\contentsline {subsection}{\numberline {25.9}Mehrdimensionale Arrays}{29}{subsection.25.9}
\contentsline {subsubsection}{\numberline {25.9.1}Initialisierung eines mehrdimensionalen Arrays}{30}{subsubsection.25.9.1}
\contentsline {section}{\numberline {26}\IeC {\"U}bergabe von Arrays und Zeichenketten}{30}{section.26}
\contentsline {subsection}{\numberline {26.1}Beispiel: Array (Vektor) als Parameter}{30}{subsection.26.1}
\contentsline {subsection}{\numberline {26.2}\IeC {\"U}bergabe einer Matrix mittels offenem Array}{30}{subsection.26.2}
\contentsline {subsection}{\numberline {26.3}Zeichenketten (Strings)}{31}{subsection.26.3}
\contentsline {section}{\numberline {27}Dynamische Speicherverwaltung}{31}{section.27}
\contentsline {subsection}{\numberline {27.1}Pro Memoria: Variablen}{31}{subsection.27.1}
\contentsline {subsection}{\numberline {27.2}Dynamische Speicherverwaltung}{31}{subsection.27.2}
\contentsline {subsection}{\numberline {27.3}Syntax}{31}{subsection.27.3}
\contentsline {subsection}{\numberline {27.4}Vorsichtsmassnahmen}{31}{subsection.27.4}
\contentsline {subsection}{\numberline {27.5}Memory Leak, Garbage Collection}{32}{subsection.27.5}
\contentsline {subsection}{\numberline {27.6}Dynamische Allozierung von Arrays}{32}{subsection.27.6}
\contentsline {subsection}{\numberline {27.7}Dynamische Allozierung von Matrizen}{32}{subsection.27.7}
\contentsline {subsubsection}{\numberline {27.7.1}Dynamische Matrix mit 4 Zeilen und 3 Spalten}{33}{subsubsection.27.7.1}
\contentsline {subsubsection}{\numberline {27.7.2}Zugriff auf dynamisch erzeugte Matrix}{33}{subsubsection.27.7.2}
\contentsline {subsubsection}{\numberline {27.7.3}Dynamische Matrix freigeben}{34}{subsubsection.27.7.3}
\contentsline {subsection}{\numberline {27.8}Effizienz der Matriximplementationen}{34}{subsection.27.8}
\contentsline {part}{V\hspace {1em}Scope, Deklarationen, Type Casts}{35}{part.5}
\contentsline {section}{\numberline {28}Strukturen in C++}{35}{section.28}
\contentsline {section}{\numberline {29}G\IeC {\"u}ltigkeitsbereiche, Namensr\IeC {\"a}ume und Sichtbarkeit}{35}{section.29}
\contentsline {subsection}{\numberline {29.1}G\IeC {\"u}ltigkeitsbereiche von Namen (Scope)}{35}{subsection.29.1}
\contentsline {subsection}{\numberline {29.2}G\IeC {\"u}ltigkeitsbereiche in C++}{35}{subsection.29.2}
\contentsline {subsection}{\numberline {29.3}G\IeC {\"u}ltigkeit (Scope) von Variablen}{35}{subsection.29.3}
\contentsline {subsection}{\numberline {29.4}Lebensdauer von Variablen}{36}{subsection.29.4}
\contentsline {subsection}{\numberline {29.5}Sichtbarkeit von Variablen}{36}{subsection.29.5}
\contentsline {subsection}{\numberline {29.6}Schlussfolgerung (naheliegend aber falsch)}{36}{subsection.29.6}
\contentsline {subsection}{\numberline {29.7}Lebensdauer (grau) und Sichtbarkeit (weiss)}{36}{subsection.29.7}
\contentsline {subsection}{\numberline {29.8}Codierstil}{36}{subsection.29.8}
\contentsline {section}{\numberline {30}Namensr\IeC {\"a}ume (Namespaces)}{37}{section.30}
\contentsline {subsection}{\numberline {30.1}Explizite Namensr\IeC {\"a}ume in C++}{37}{subsection.30.1}
\contentsline {subsection}{\numberline {30.2}C++-Mechanismen f\IeC {\"u}r Namespaces}{37}{subsection.30.2}
\contentsline {subsection}{\numberline {30.3}Deklaration von Namespaces}{37}{subsection.30.3}
\contentsline {subsubsection}{\numberline {30.3.1}Beispiel}{38}{subsubsection.30.3.1}
\contentsline {subsection}{\numberline {30.4}using-Deklaration}{38}{subsection.30.4}
\contentsline {subsection}{\numberline {30.5}using-Direktive}{38}{subsection.30.5}
\contentsline {subsection}{\numberline {30.6}using namespace kann zu Konflikten f\IeC {\"u}hren}{38}{subsection.30.6}
\contentsline {subsection}{\numberline {30.7}Namenlose Namespaces}{39}{subsection.30.7}
\contentsline {subsection}{\numberline {30.8}Zugriff auf globale Variable mit Scope-Operator}{39}{subsection.30.8}
\contentsline {section}{\numberline {31}Speicherklassen}{39}{section.31}
\contentsline {subsection}{\numberline {31.1}Speicherklassen in C++}{39}{subsection.31.1}
\contentsline {subsubsection}{\numberline {31.1.1}Speicherklasse static: Variablen}{40}{subsubsection.31.1.1}
\contentsline {subsubsection}{\numberline {31.1.2}Speicherklasse static: Funktionen}{40}{subsubsection.31.1.2}
\contentsline {subsubsection}{\numberline {31.1.3}Speicherklasse extern: Externe Variablen}{40}{subsubsection.31.1.3}
\contentsline {subsection}{\numberline {31.2}Typqualifikationen (Kap. 9.2.2)}{40}{subsection.31.2}
\contentsline {subsection}{\numberline {31.3}Funktionsattribute}{40}{subsection.31.3}
\contentsline {section}{\numberline {32}Typdefinitionen}{41}{section.32}
\contentsline {subsection}{\numberline {32.1}typedef zur Vereinbarung eigener Datentypen\hfill }{41}{subsection.32.1}
\contentsline {subsubsection}{\numberline {32.1.1}Beispiel}{41}{subsubsection.32.1.1}
\contentsline {subsection}{\numberline {32.2}Gew\IeC {\"a}hrleistung von Portabilit\IeC {\"a}t}{41}{subsection.32.2}
\contentsline {subsection}{\numberline {32.3}Wie setzt der Compiler ein typedef um?}{42}{subsection.32.3}
\contentsline {section}{\numberline {33}Initialisierung}{42}{section.33}
\contentsline {section}{\numberline {34}Type-Cast (Typumwandlungen)}{42}{section.34}
\contentsline {subsection}{\numberline {34.1}Typumwandlungen im Allgemeinen}{42}{subsection.34.1}
\contentsline {subsection}{\numberline {34.2}Implizite Typumwandlung}{42}{subsection.34.2}
\contentsline {subsection}{\numberline {34.3}Explizite Typumwandlung}{42}{subsection.34.3}
\contentsline {subsubsection}{\numberline {34.3.1}Explizite Typumwandlung \#1, 2: C-Stil und Funktionsstil}{42}{subsubsection.34.3.1}
\contentsline {subsubsection}{\numberline {34.3.2}Typumwandlung mit C-Stil und Funktionsstil}{43}{subsubsection.34.3.2}
\contentsline {subsubsection}{\numberline {34.3.3}Explizite Typumwandlung \#3: const\_cast}{43}{subsubsection.34.3.3}
\contentsline {subsubsection}{\numberline {34.3.4}Explizite Typumwandlung \#4: static\_cast}{43}{subsubsection.34.3.4}
\contentsline {subsubsection}{\numberline {34.3.5}Explizite Typumwandlung \#5: dynamic\_cast}{43}{subsubsection.34.3.5}
\contentsline {subsubsection}{\numberline {34.3.6}Explizite Typumwandlung \#6: reinterpret\_cast}{43}{subsubsection.34.3.6}
\contentsline {part}{VI\hspace {1em}Module und Datenkapseln}{45}{part.6}
\contentsline {section}{\numberline {35}Modul (Unit)}{45}{section.35}
\contentsline {subsection}{\numberline {35.1}Nomenklatur: Modul vs. Unit}{45}{subsection.35.1}
\contentsline {subsection}{\numberline {35.2}Ziele der Modularisierung}{45}{subsection.35.2}
\contentsline {subsection}{\numberline {35.3}Eigenschaften einer Unit (eines Moduls)}{45}{subsection.35.3}
\contentsline {subsection}{\numberline {35.4}Bestandteile eine C++-Programms}{45}{subsection.35.4}
\contentsline {subsection}{\numberline {35.5}Unitkonzept}{45}{subsection.35.5}
\contentsline {subsection}{\numberline {35.6}Geheimnisprinpzip (Information Hiding)}{45}{subsection.35.6}
\contentsline {subsubsection}{\numberline {35.6.1}Information Hiding}{45}{subsubsection.35.6.1}
\contentsline {subsubsection}{\numberline {35.6.2}Konzept der Datenkapsel}{46}{subsubsection.35.6.2}
\contentsline {subsubsection}{\numberline {35.6.3}Beispiel f\IeC {\"u}r Datenzugriff bei Datenkapsel}{46}{subsubsection.35.6.3}
\contentsline {subsubsection}{\numberline {35.6.4}Beispiel f\IeC {\"u}r Unit Rechteck (ohne Datenkapsel)}{47}{subsubsection.35.6.4}
\contentsline {subsubsection}{\numberline {35.6.5}Beispiel f\IeC {\"u}r Unit Rechteck: Verbesserung \#1}{47}{subsubsection.35.6.5}
\contentsline {subsubsection}{\numberline {35.6.6}Beispiel f\IeC {\"u}r Unit Rechteck: Verbesserung \#2}{48}{subsubsection.35.6.6}
\contentsline {subsection}{\numberline {35.7}Unit nutzen}{48}{subsection.35.7}
\contentsline {subsection}{\numberline {35.8}Unit-Schnittstelle definieren (in Headerdatei)}{48}{subsection.35.8}
\contentsline {subsection}{\numberline {35.9}Deklarationsreihenfolge in der Headerdatei (*.h)}{48}{subsection.35.9}
\contentsline {subsection}{\numberline {35.10}Reihenfolge in der Implementierungsdatei (*.cpp)}{49}{subsection.35.10}
\contentsline {subsection}{\numberline {35.11}\#include-Konzept}{49}{subsection.35.11}
\contentsline {subsection}{\numberline {35.12}Unit compilieren}{49}{subsection.35.12}
\contentsline {subsection}{\numberline {35.13}Units linken}{49}{subsection.35.13}
\contentsline {subsection}{\numberline {35.14}Buildprozess}{49}{subsection.35.14}
\contentsline {subsection}{\numberline {35.15}Make-Tool}{50}{subsection.35.15}
\contentsline {subsubsection}{\numberline {35.15.1}Abh\IeC {\"a}ngigkeiten zwischen Dateien}{50}{subsubsection.35.15.1}
\contentsline {subsubsection}{\numberline {35.15.2}make-File}{50}{subsubsection.35.15.2}
\contentsline {subsubsection}{\numberline {35.15.3}Beispiel: makefile}{50}{subsubsection.35.15.3}
\contentsline {part}{VII\hspace {1em}Eclipse IDE}{51}{part.7}
\contentsline {section}{\numberline {36}Eclipse}{51}{section.36}
\contentsline {subsection}{\numberline {36.1}Workspace}{51}{subsection.36.1}
\contentsline {subsection}{\numberline {36.2}Ressourcen (Resources)}{51}{subsection.36.2}
\contentsline {subsection}{\numberline {36.3}Project}{51}{subsection.36.3}
\contentsline {subsection}{\numberline {36.4}Debugger}{51}{subsection.36.4}
\contentsline {subsubsection}{\numberline {36.4.1}Testen und Debugging}{51}{subsubsection.36.4.1}
\contentsline {subsubsection}{\numberline {36.4.2}Funktionen eines Debuggers}{51}{subsubsection.36.4.2}
\contentsline {subsubsection}{\numberline {36.4.3}Assertions (Zusicherungen)}{51}{subsubsection.36.4.3}
\contentsline {subsubsection}{\numberline {36.4.4}Zu beachten bei Assertions}{52}{subsubsection.36.4.4}
\contentsline {part}{VIII\hspace {1em}Klassen}{53}{part.8}
\contentsline {section}{\numberline {37}Beispielprojekt Stack}{53}{section.37}
\contentsline {subsection}{\numberline {37.1}Stack}{53}{subsection.37.1}
\contentsline {subsubsection}{\numberline {37.1.1}Stack - Operationen}{53}{subsubsection.37.1.1}
\contentsline {subsubsection}{\numberline {37.1.2}Demo: Codebeispiel f\IeC {\"u}r Stack (Stack\_Datenkapsel)}{53}{subsubsection.37.1.2}
\contentsline {subsection}{\numberline {37.2}Queue}{56}{subsection.37.2}
\contentsline {subsubsection}{\numberline {37.2.1}Queue - Operationen}{57}{subsubsection.37.2.1}
\contentsline {section}{\numberline {38}Objektorientierte Programmierung}{57}{section.38}
\contentsline {subsection}{\numberline {38.1}Modell und Realit\IeC {\"a}t}{57}{subsection.38.1}
\contentsline {subsection}{\numberline {38.2}Zu (subjektiven) Sichtweise des Betrachters}{57}{subsection.38.2}
\contentsline {subsection}{\numberline {38.3}Prozedurale vs. Objektorientierte Sicht}{57}{subsection.38.3}
\contentsline {section}{\numberline {39}Unified Modeling Language (UML)}{57}{section.39}
\contentsline {subsection}{\numberline {39.1}Entstehung der UML}{57}{subsection.39.1}
\contentsline {subsection}{\numberline {39.2}Was ist UML?}{57}{subsection.39.2}
\contentsline {subsection}{\numberline {39.3}Klassenbegriff}{58}{subsection.39.3}
\contentsline {subsection}{\numberline {39.4}UML-Notation der Klasse}{58}{subsection.39.4}
\contentsline {subsection}{\numberline {39.5}Klasse definieren und Objekte anlegen: Syntax}{58}{subsection.39.5}
\contentsline {section}{\numberline {40}Zugriffsschutz bei Klassen}{59}{section.40}
\contentsline {subsection}{\numberline {40.1}Zugriffsschutz mit public, protected und private}{59}{subsection.40.1}
\contentsline {subsubsection}{\numberline {40.1.1}\IeC {\"U}blicher Aufbau einer Klassenschnittstelle}{59}{subsubsection.40.1.1}
\contentsline {subsection}{\numberline {40.2}Operationen einer Klasse}{59}{subsection.40.2}
\contentsline {subsection}{\numberline {40.3}Information Hiding}{60}{subsection.40.3}
\contentsline {section}{\numberline {41}Beispiel einer Klasse: Rechteck (Rectangle)}{60}{section.41}
\contentsline {subsection}{\numberline {41.1}Klassendeklaration}{60}{subsection.41.1}
\contentsline {subsection}{\numberline {41.2}Klassendefinition}{61}{subsection.41.2}
\contentsline {subsection}{\numberline {41.3}Klassendefinition direkt}{61}{subsection.41.3}
\contentsline {subsection}{\numberline {41.4}Reprise: Projekt Stack}{61}{subsection.41.4}
\contentsline {subsection}{\numberline {41.5}Klassenschnittstelle}{62}{subsection.41.5}
\contentsline {section}{\numberline {42}Elementfunktionen}{62}{section.42}
\contentsline {subsection}{\numberline {42.1}Klassifizierung von Elementfunktionen}{62}{subsection.42.1}
\contentsline {subsection}{\numberline {42.2}inline-Elementfunktionen}{62}{subsection.42.2}
\contentsline {subsection}{\numberline {42.3}Projekt Stack}{62}{subsection.42.3}
\contentsline {subsection}{\numberline {42.4}const - Elementfunktionen}{62}{subsection.42.4}
\contentsline {subsubsection}{\numberline {42.4.1}const - Elementfunktionen: Schlussfolgerung}{63}{subsubsection.42.4.1}
\contentsline {subsection}{\numberline {42.5}Projekt Stack}{63}{subsection.42.5}
\contentsline {subsection}{\numberline {42.6}mutable-Attribut}{63}{subsection.42.6}
\contentsline {subsection}{\numberline {42.7}Projekt Stack}{64}{subsection.42.7}
\contentsline {section}{\numberline {43}Konstruktoren/Destruktoren}{64}{section.43}
\contentsline {subsection}{\numberline {43.1}this-Pointer}{64}{subsection.43.1}
\contentsline {subsection}{\numberline {43.2}friend-Elemente}{64}{subsection.43.2}
\contentsline {subsection}{\numberline {43.3}static-Klassenelemente (Kap.11.5)}{65}{subsection.43.3}
\contentsline {subsubsection}{\numberline {43.3.1}Syntax}{65}{subsubsection.43.3.1}
\contentsline {subsection}{\numberline {43.4}Konstruktor (Constructor, Ctor)}{65}{subsection.43.4}
\contentsline {subsubsection}{\numberline {43.4.1}Aufruf}{65}{subsubsection.43.4.1}
\contentsline {subsubsection}{\numberline {43.4.2}Beispiel: Klasse TString (nach Lippman)}{66}{subsubsection.43.4.2}
\contentsline {subsubsection}{\numberline {43.4.3}Implementation von TString::TString()}{67}{subsubsection.43.4.3}
\contentsline {subsubsection}{\numberline {43.4.4}\IeC {\"U}berladen von Konstruktoren}{67}{subsubsection.43.4.4}
\contentsline {subsubsection}{\numberline {43.4.5}Erweiterung der Klasse TString}{67}{subsubsection.43.4.5}
\contentsline {subsubsection}{\numberline {43.4.6}Konstruktoren und Function Casts}{68}{subsubsection.43.4.6}
\contentsline {subsubsection}{\numberline {43.4.7}Erweiterung der Klasse TString 2}{69}{subsubsection.43.4.7}
\contentsline {subsubsection}{\numberline {43.4.8}Copy-Konstruktor}{69}{subsubsection.43.4.8}
\contentsline {subsubsection}{\numberline {43.4.9}Copy-Konstruktor wird automatisch aufgerufen, wenn...}{69}{subsubsection.43.4.9}
\contentsline {subsubsection}{\numberline {43.4.10}Erweiterung der Klasse TString 3}{70}{subsubsection.43.4.10}
\contentsline {subsubsection}{\numberline {43.4.11}Shallow Copy vs. Deep Copy}{70}{subsubsection.43.4.11}
\contentsline {subsubsection}{\numberline {43.4.12}Copy-Konstruktor der Klasse TString}{71}{subsubsection.43.4.12}
\contentsline {subsection}{\numberline {43.5}Destruktor (Destructor, Dtor)}{71}{subsection.43.5}
\contentsline {subsubsection}{\numberline {43.5.1}Eigenschaften des Destruktors}{71}{subsubsection.43.5.1}
\contentsline {subsubsection}{\numberline {43.5.2}Erweiterung der Klasse TString 4}{71}{subsubsection.43.5.2}
\contentsline {subsubsection}{\numberline {43.5.3}Implementation des Destruktors}{72}{subsubsection.43.5.3}
\contentsline {subsubsection}{\numberline {43.5.4}Schnittstelle der Klasse TString}{72}{subsubsection.43.5.4}
\contentsline {subsubsection}{\numberline {43.5.5}Demo: Klasse Stack}{72}{subsubsection.43.5.5}
\contentsline {section}{\numberline {44}Handhabung von Klassen und Objekten}{72}{section.44}
\contentsline {subsection}{\numberline {44.1}Repetition}{72}{subsection.44.1}
\contentsline {subsection}{\numberline {44.2}Welche Ctors werden bei folgenden Anweisungen aufgerufen?}{73}{subsection.44.2}
\contentsline {subsection}{\numberline {44.3}Automatisch generierte Elementfunktionen (11.7.4)}{73}{subsection.44.3}
\contentsline {subsection}{\numberline {44.4}Kanonische Form von Klassen (11.7.5)}{73}{subsection.44.4}
\contentsline {subsection}{\numberline {44.5}Benutzerdefinierte Typumwandlungen: Problemstellung \& L\IeC {\"o}sung}{73}{subsection.44.5}
\contentsline {subsection}{\numberline {44.6}Typumwandlung mit Konstruktor}{74}{subsection.44.6}
\contentsline {subsection}{\numberline {44.7}Weiterf\IeC {\"u}hrende Themen}{74}{subsection.44.7}
\contentsline {subsubsection}{\numberline {44.7.1}Zeiger auf Klassenelemente}{74}{subsubsection.44.7.1}
\contentsline {subsection}{\numberline {44.8}Unions (Varianten)}{74}{subsection.44.8}
\contentsline {subsubsection}{\numberline {44.8.1}Eigenschaften einer Union}{74}{subsubsection.44.8.1}
\contentsline {subsubsection}{\numberline {44.8.2}Definition von Uniontypen und Unionvariablen}{75}{subsubsection.44.8.2}
\contentsline {subsubsection}{\numberline {44.8.3}Beispiel: Definition einer Union}{75}{subsubsection.44.8.3}
\contentsline {subsection}{\numberline {44.9}Bitfelder}{75}{subsection.44.9}
\contentsline {subsubsection}{\numberline {44.9.1}Eigenschaften von Bitfeldern}{75}{subsubsection.44.9.1}
\contentsline {subsubsection}{\numberline {44.9.2}Definition von von Bitfeldern}{76}{subsubsection.44.9.2}
\contentsline {subsubsection}{\numberline {44.9.3}Bitfelder: Folgerungen}{76}{subsubsection.44.9.3}
\contentsline {subsection}{\numberline {44.10}Demo: Klasse Date}{76}{subsection.44.10}
\contentsline {part}{IX\hspace {1em}Vererbung}{77}{part.9}
\contentsline {section}{\numberline {45}Motivation}{77}{section.45}
\contentsline {section}{\numberline {46}Artikel als Gemeinsamkeit von Buch und CD}{77}{section.46}
\contentsline {section}{\numberline {47}Grundkonzept}{77}{section.47}
\contentsline {section}{\numberline {48}Einsatz der Vererbung}{77}{section.48}
\contentsline {section}{\numberline {49}UML-Notation}{77}{section.49}
\contentsline {subsection}{\numberline {49.1}"ist ein"-Beziehung}{77}{subsection.49.1}
\contentsline {section}{\numberline {50}Beispiel: Vererbungshierarchie Lebewesen}{77}{section.50}
\contentsline {subsection}{\numberline {50.1}C++-Syntax}{77}{subsection.50.1}
\contentsline {subsection}{\numberline {50.2}Zugriff auf Elemente der Basisklasse}{78}{subsection.50.2}
\contentsline {section}{\numberline {51}Spezifikation von Basisklassen}{78}{section.51}
\contentsline {section}{\numberline {52}Beispiel: ComicCharacter (Comics01)}{78}{section.52}
\contentsline {section}{\numberline {53}Einsatz von protected bei Klassenelementen}{78}{section.53}
\contentsline {section}{\numberline {54}Objektgr\IeC {\"o}sse bei der Vererbung}{78}{section.54}
\contentsline {section}{\numberline {55}Schlechter (falscher) Einsatz von Vererbung}{78}{section.55}
\contentsline {section}{\numberline {56}Substitutionsprinzip}{78}{section.56}
\contentsline {part}{X\hspace {1em}Polymorphismus}{79}{part.10}
\contentsline {section}{\numberline {57}Static vs. Dynamic Binding}{79}{section.57}
\contentsline {subsection}{\numberline {57.1}Dynamic Binding}{79}{subsection.57.1}
\contentsline {subsubsection}{\numberline {57.1.1}Beispiel: Zeichnen von geometrischen Figuren}{79}{subsubsection.57.1.1}
\contentsline {subsection}{\numberline {57.2}Statischer vs. dynamischer Datentyp}{79}{subsection.57.2}
\contentsline {subsection}{\numberline {57.3}Aufruf von virtuellen Elementfunktionen}{80}{subsection.57.3}
\contentsline {subsubsection}{\numberline {57.3.1}Statischer Aufruf von virtuellen Elementfunktionen}{80}{subsubsection.57.3.1}
\contentsline {subsubsection}{\numberline {57.3.2}Dynamischer Aufruf von virtuellen Elementfunktionen}{80}{subsubsection.57.3.2}
\contentsline {subsection}{\numberline {57.4}Polymorphe Klassen (Virtuelle Klassen)}{80}{subsection.57.4}
\contentsline {subsubsection}{\numberline {57.4.1}Repr\IeC {\"a}sentation virtueller Objekte im Speicher}{81}{subsubsection.57.4.1}
\contentsline {section}{\numberline {58}Abstrakte Klassen}{81}{section.58}
\contentsline {subsection}{\numberline {58.1}Anwendungen von abstrakten Klassen (Beispiele)}{81}{subsection.58.1}
\contentsline {section}{\numberline {59}Mehrfachvererbung (Multiple Inheritance, MI)}{81}{section.59}
\contentsline {subsection}{\numberline {59.1}Virtuelle Basisklassen}{82}{subsection.59.1}
\contentsline {section}{\numberline {60}Laufzeit-Typinformationen (Run-Time Type Information, RTTI)}{82}{section.60}
\contentsline {subsection}{\numberline {60.1}Operator dynamic\_cast}{82}{subsection.60.1}
\contentsline {subsection}{\numberline {60.2}Operator typeid}{83}{subsection.60.2}
\contentsline {part}{XI\hspace {1em}\IeC {\"U}berladen von Operatoren (Operator overloading)}{84}{part.11}
\contentsline {section}{\numberline {61}Operator overloading in C++}{84}{section.61}
\contentsline {subsection}{\numberline {61.1}Operatorfunktion}{84}{subsection.61.1}
\contentsline {subsection}{\numberline {61.2}Randbedingungen zu Operator overloading}{84}{subsection.61.2}
\contentsline {subsection}{\numberline {61.3}Umsetzungsvarianten f\IeC {\"u}r Operator overloading}{85}{subsection.61.3}
\contentsline {subsubsection}{\numberline {61.3.1}Beispiel}{86}{subsubsection.61.3.1}
\contentsline {subsubsection}{\numberline {61.3.2}Zuweisungsoperator =}{87}{subsubsection.61.3.2}
\contentsline {subsubsection}{\numberline {61.3.3}Indexoperator []}{87}{subsubsection.61.3.3}
\contentsline {subsubsection}{\numberline {61.3.4}Beispiel Klasse TString}{87}{subsubsection.61.3.4}
\contentsline {subsubsection}{\numberline {61.3.5}Eigenen Zuweisungsoperator definieren}{88}{subsubsection.61.3.5}
\contentsline {subsubsection}{\numberline {61.3.6}Zur Erinnerung: Kanonische Form einer Klasse}{88}{subsubsection.61.3.6}
\contentsline {subsection}{\numberline {61.4}Streamkonzept}{88}{subsection.61.4}
\contentsline {subsubsection}{\numberline {61.4.1}Ausgabe: Klasse ostream}{88}{subsubsection.61.4.1}
\contentsline {subsubsection}{\numberline {61.4.2}Operator << \IeC {\"u}berschreiben}{88}{subsubsection.61.4.2}
\contentsline {subsubsection}{\numberline {61.4.3}Eingabe: Klasse istream}{88}{subsubsection.61.4.3}
\contentsline {subsubsection}{\numberline {61.4.4}Operator >> \IeC {\"u}berschreiben}{89}{subsubsection.61.4.4}
\contentsline {part}{XII\hspace {1em}Templates}{90}{part.12}
\contentsline {section}{\numberline {62}Generische Programmierung mit Templates (Schablonen)}{90}{section.62}
\contentsline {subsection}{\numberline {62.1}Motivation f\IeC {\"u}r Templates}{90}{subsection.62.1}
\contentsline {subsection}{\numberline {62.2}L\IeC {\"o}sung mit bekannten Techniken}{90}{subsection.62.2}
\contentsline {subsection}{\numberline {62.3}Generische Programmierung mit Templates}{90}{subsection.62.3}
\contentsline {section}{\numberline {63}Funktions-Templates}{90}{section.63}
\contentsline {subsection}{\numberline {63.1}Syntax f\IeC {\"u}r Funktions-Templates}{90}{subsection.63.1}
\contentsline {subsection}{\numberline {63.2}Beispiel (aus Prata): Zwei Werte vertauschen}{91}{subsection.63.2}
\contentsline {subsection}{\numberline {63.3}inline bei Templates}{91}{subsection.63.3}
\contentsline {subsection}{\numberline {63.4}Beispiel: kleinstes Element finden}{91}{subsection.63.4}
\contentsline {subsection}{\numberline {63.5}Auspr\IeC {\"a}gung von Funktions-Templates}{92}{subsection.63.5}
\contentsline {subsection}{\numberline {63.6}Explizite Qualifizierung von Funktions-Templates}{92}{subsection.63.6}
\contentsline {subsection}{\numberline {63.7}\IeC {\"U}berladen von Funktions-Templates}{92}{subsection.63.7}
\contentsline {section}{\numberline {64}Klassen-Templates}{92}{section.64}
\contentsline {subsection}{\numberline {64.1}Definition: Klassen-Template}{92}{subsection.64.1}
\contentsline {subsection}{\numberline {64.2}Syntax f\IeC {\"u}r Klassen-Templates}{92}{subsection.64.2}
\contentsline {subsubsection}{\numberline {64.2.1}Beispiel zu Klassen-Template: Deklaration}{93}{subsubsection.64.2.1}
\contentsline {subsubsection}{\numberline {64.2.2}Beispiel zu Klassen-Template: Definition}{93}{subsubsection.64.2.2}
\contentsline {subsubsection}{\numberline {64.2.3}Beispiel zu Klassen-Template: Nutzung (Auspr\IeC {\"a}gung)}{93}{subsubsection.64.2.3}
\contentsline {subsection}{\numberline {64.3}Bemerkungen}{93}{subsection.64.3}
\contentsline {subsection}{\numberline {64.4}Explizite Auspr\IeC {\"a}gung von Klassen-Templates}{94}{subsection.64.4}
\contentsline {subsection}{\numberline {64.5}Klassen-Templates und getrennte \IeC {\"U}bersetzung: export}{94}{subsection.64.5}
\contentsline {subsection}{\numberline {64.6}Klassen-Templates und getrennte \IeC {\"U}bersetzung}{94}{subsection.64.6}
\contentsline {subsubsection}{\numberline {64.6.1}File-Organisation \#1 bei Klassen-Templates}{94}{subsubsection.64.6.1}
\contentsline {subsubsection}{\numberline {64.6.2}Ausschliessen eines cpp-Files von Compilierung in Eclipse}{94}{subsubsection.64.6.2}
\contentsline {subsubsection}{\numberline {64.6.3}File-Organisation \#2 bei Klassen-Templates}{94}{subsubsection.64.6.3}
\contentsline {subsection}{\numberline {64.7}Fazit}{95}{subsection.64.7}
\contentsline {part}{XIII\hspace {1em}Exceptions ("`Ausnahmen"')}{96}{part.13}
\contentsline {section}{\numberline {65}Exception vs. Error}{96}{section.65}
\contentsline {section}{\numberline {66}M\IeC {\"o}gliche Reaktionen auf Ausnahmen}{96}{section.66}
\contentsline {section}{\numberline {67}Exceptioncodes als R\IeC {\"u}ckgabewert}{96}{section.67}
\contentsline {section}{\numberline {68}Exceptioncodes als Referenzparameter}{96}{section.68}
\contentsline {section}{\numberline {69}Globaler Exceptioncode}{97}{section.69}
\contentsline {section}{\numberline {70}Wo sollen Exceptions behandelt werden?}{97}{section.70}
\contentsline {subsection}{\numberline {70.1}Beispiel: \IeC {\"U}bertragungssystem}{97}{subsection.70.1}
\contentsline {section}{\numberline {71}Ziel f\IeC {\"u}r Exception Handling}{97}{section.71}
\contentsline {section}{\numberline {72}Exception Handling in C++}{97}{section.72}
\contentsline {subsection}{\numberline {72.1}Exception Handling in C++: Syntax}{98}{subsection.72.1}
\contentsline {subsection}{\numberline {72.2}Ausl\IeC {\"o}sen (Werfen) von Ausnahmen}{98}{subsection.72.2}
\contentsline {subsubsection}{\numberline {72.2.1}Beispiel f\IeC {\"u}r Exception Handling: un\IeC {\"u}bliche Variante}{99}{subsubsection.72.2.1}
\contentsline {subsection}{\numberline {72.3}Vordefinierte Ausnahmeklassen}{99}{subsection.72.3}
\contentsline {subsection}{\numberline {72.4}Exception-Hierarchie in C++}{99}{subsection.72.4}
\contentsline {subsection}{\numberline {72.5}Laufzeit- vs. Logische "`Fehler"'}{99}{subsection.72.5}
\contentsline {subsection}{\numberline {72.6}Exceptions und ihre Header-Dateien}{100}{subsection.72.6}
\contentsline {subsection}{\numberline {72.7}Exception Handler}{100}{subsection.72.7}
\contentsline {subsubsection}{\numberline {72.7.1}Handler mit beliebigne Exceptions ohne Hierarchie}{100}{subsubsection.72.7.1}
\contentsline {subsubsection}{\numberline {72.7.2}Handler mit System-Exceptions}{100}{subsubsection.72.7.2}
\contentsline {subsubsection}{\numberline {72.7.3}Handler mit schlechter Reihenfolge}{100}{subsubsection.72.7.3}
\contentsline {subsection}{\numberline {72.8}Exception Handler 2}{100}{subsection.72.8}
\contentsline {subsection}{\numberline {72.9}Exception Propagation}{100}{subsection.72.9}
\contentsline {subsection}{\numberline {72.10}Exception Specification}{100}{subsection.72.10}
\contentsline {subsubsection}{\numberline {72.10.1}Exception Specification: Beispiele}{101}{subsubsection.72.10.1}
\contentsline {subsubsection}{\numberline {72.10.2}Exception Handling in der Praxis}{101}{subsubsection.72.10.2}
\contentsline {subsubsection}{\numberline {72.10.3}Throw exceptions by value, catch them by const reference}{101}{subsubsection.72.10.3}
\contentsline {subsubsection}{\numberline {72.10.4}Handling von System Exceptions}{101}{subsubsection.72.10.4}
\contentsline {subsubsection}{\numberline {72.10.5}Handling-Strategie von System Exceptions bei verschiedenen Programmiersprachen}{101}{subsubsection.72.10.5}
\contentsline {subsubsection}{\numberline {72.10.6}Betreibt meine Umgebung Exception Mapping?}{102}{subsubsection.72.10.6}
\contentsline {part}{XIV\hspace {1em}Preprocessor}{103}{part.14}
\contentsline {section}{\numberline {73}Eigenschaften des Preprocessors}{103}{section.73}
\contentsline {section}{\numberline {74}Preprocessor-Direktiven und Bedingungsanweisungen}{103}{section.74}
\contentsline {subsection}{\numberline {74.1}\#define}{103}{subsection.74.1}
\contentsline {subsection}{\numberline {74.2}\#undef}{103}{subsection.74.2}
\contentsline {subsection}{\numberline {74.3}\#include}{104}{subsection.74.3}
\contentsline {subsection}{\numberline {74.4}\#line}{104}{subsection.74.4}
\contentsline {subsection}{\numberline {74.5}\#error}{104}{subsection.74.5}
\contentsline {subsection}{\numberline {74.6}\#pragma}{104}{subsection.74.6}
\contentsline {subsection}{\numberline {74.7}Bedingungsanweisungen}{104}{subsection.74.7}
\contentsline {subsubsection}{\numberline {74.7.1}Beispiele f\IeC {\"u}r Bedingungsanweisungen}{105}{subsubsection.74.7.1}
\contentsline {subsection}{\numberline {74.8}Weitere Features des Preprocessors}{105}{subsection.74.8}
\contentsline {subsection}{\numberline {74.9}Kritische W\IeC {\"u}rdigung des Preprocessors}{105}{subsection.74.9}
