\select@language {ngerman}
\contentsline {section}{\numberline {1}Kapitel 1\hfill }{5}{section.1}
\contentsline {subsection}{\numberline {1.1}Einf\IeC {\"u}hrung\hfill }{5}{subsection.1.1}
\contentsline {subsubsection}{\numberline {1.1.1}Charakteristiken von C++\hfill }{5}{subsubsection.1.1.1}
\contentsline {subsubsection}{\numberline {1.1.2}Entstehung von C++\hfill }{5}{subsubsection.1.1.2}
\contentsline {subsubsection}{\numberline {1.1.3}Welches C++?\hfill }{5}{subsubsection.1.1.3}
\contentsline {subsubsection}{\numberline {1.1.4}C++-Unterst\IeC {\"u}tzung von Texas Instruments (TI)\hfill }{5}{subsubsection.1.1.4}
\contentsline {subsubsection}{\numberline {1.1.5}Hello World!\hfill }{6}{subsubsection.1.1.5}
\contentsline {subsubsection}{\numberline {1.1.6}C++-Compiler (noch nicht Eclipse)\hfill }{6}{subsubsection.1.1.6}
\contentsline {subsection}{\numberline {1.2}Lexikalische Elemente von C++\hfill }{6}{subsection.1.2}
\contentsline {subsubsection}{\numberline {1.2.1}Lexikalische Elemente\hfill }{6}{subsubsection.1.2.1}
\contentsline {subsubsection}{\numberline {1.2.2}Styleguide: Bezeichner (\raisebox {-0.9ex}{\~{ }}Namen)\hfill }{6}{subsubsection.1.2.2}
\contentsline {subsection}{\numberline {1.3}Typkonzept\hfill }{7}{subsection.1.3}
\contentsline {subsubsection}{\numberline {1.3.1}Datentypen\hfill }{7}{subsubsection.1.3.1}
\contentsline {subsubsection}{\numberline {1.3.2}\#define (Kap. 4.5)\hfill }{7}{subsubsection.1.3.2}
\contentsline {subsection}{\numberline {1.4}Ausdr\IeC {\"u}cke und Operatoren\hfill }{7}{subsection.1.4}
\contentsline {subsubsection}{\numberline {1.4.1}Ausdr\IeC {\"u}cke und Operatoren\hfill }{7}{subsubsection.1.4.1}
\contentsline {subsection}{\numberline {1.5}Anweisungen\hfill }{8}{subsection.1.5}
\contentsline {subsubsection}{\numberline {1.5.1}Anweisungen: ebenfalls nichts neues\hfill }{8}{subsubsection.1.5.1}
\contentsline {subsection}{\numberline {1.6}Streams\hfill }{8}{subsection.1.6}
\contentsline {subsubsection}{\numberline {1.6.1}Streamkonzept\hfill }{8}{subsubsection.1.6.1}
\contentsline {subsubsection}{\numberline {1.6.2}Einsatz von Streams\hfill }{8}{subsubsection.1.6.2}
\contentsline {subsubsection}{\numberline {1.6.3}Ausgabe: Klasse ostream\hfill }{9}{subsubsection.1.6.3}
\contentsline {subsubsection}{\numberline {1.6.4}Eingabe: Klasse istream}{9}{subsubsection.1.6.4}
\contentsline {subsubsection}{\numberline {1.6.5}Formatierte Ein- und Ausgabe\hfill }{9}{subsubsection.1.6.5}
\contentsline {subsubsection}{\numberline {1.6.6}Format-Flags um \IeC {\"U}berblick (unvollst\IeC {\"a}ndig)\hfill }{9}{subsubsection.1.6.6}
\contentsline {section}{\numberline {2}Kapitel 2: Funktionen\hfill }{10}{section.2}
\contentsline {subsection}{\numberline {2.1}Grundlegendes\hfill }{10}{subsection.2.1}
\contentsline {subsubsection}{\numberline {2.1.1}Synonyme f\IeC {\"u}r Funktionen\hfill }{10}{subsubsection.2.1.1}
\contentsline {subsubsection}{\numberline {2.1.2}Aufgabe einer Funktion\hfill }{10}{subsubsection.2.1.2}
\contentsline {subsubsection}{\numberline {2.1.3}Funktionen (Vergleich zu C)\hfill }{10}{subsubsection.2.1.3}
\contentsline {subsubsection}{\numberline {2.1.4}Definition von Funktionen\hfill }{10}{subsubsection.2.1.4}
\contentsline {subsubsection}{\numberline {2.1.5}Deklaration von Funktionen (Funktionsprototypen)}{11}{subsubsection.2.1.5}
\contentsline {subsubsection}{\numberline {2.1.6}Kosten einer Funktion\hfill }{11}{subsubsection.2.1.6}
\contentsline {subsection}{\numberline {2.2}C-Makro\hfill }{11}{subsection.2.2}
\contentsline {subsubsection}{\numberline {2.2.1}C-Makro mit \#define\hfill }{11}{subsubsection.2.2.1}
\contentsline {subsubsection}{\numberline {2.2.2}Beispiel mit C-Makro: Maximum zweier int-Werte\hfill }{12}{subsubsection.2.2.2}
\contentsline {subsubsection}{\numberline {2.2.3}Beispiel mit C-Makro: Was passiert wirklich?\hfill }{12}{subsubsection.2.2.3}
\contentsline {subsection}{\numberline {2.3}inline-Funktionen\hfill }{12}{subsection.2.3}
\contentsline {subsubsection}{\numberline {2.3.1}inline-Funktionen: Grundlegendes\hfill }{12}{subsubsection.2.3.1}
\contentsline {subsubsection}{\numberline {2.3.2}Beispiel mit inline-Code: Maximum zweier int-Werte}{13}{subsubsection.2.3.2}
\contentsline {subsection}{\numberline {2.4}Grunds\IeC {\"a}tze f\IeC {\"u}r Optimierungen\hfill }{13}{subsection.2.4}
\contentsline {subsection}{\numberline {2.5}default-Argumente\hfill }{13}{subsection.2.5}
\contentsline {subsubsection}{\numberline {2.5.1}Vorbelegte Parameter (default-Argumente)\hfill }{13}{subsubsection.2.5.1}
\contentsline {subsubsection}{\numberline {2.5.2}Beispiel: default-Argumente\hfill }{14}{subsubsection.2.5.2}
\contentsline {subsubsection}{\numberline {2.5.3}Nutzen von default-Argumenten\hfill }{14}{subsubsection.2.5.3}
\contentsline {subsection}{\numberline {2.6}Overloading\hfill }{14}{subsection.2.6}
\contentsline {subsubsection}{\numberline {2.6.1}\IeC {\"U}berladen von Funktionen (overloading)\hfill }{14}{subsubsection.2.6.1}
\contentsline {subsubsection}{\numberline {2.6.2}Overloading in C++\hfill }{14}{subsubsection.2.6.2}
\contentsline {subsubsection}{\numberline {2.6.3}Deklaration von \IeC {\"u}berladenen Funktionen: Regeln\hfill }{15}{subsubsection.2.6.3}
\contentsline {subsubsection}{\numberline {2.6.4}Funktionen sollen nur dann \IeC {\"u}berladen werden, wenn ...\hfill }{15}{subsubsection.2.6.4}
\contentsline {subsection}{\numberline {2.7}default-Parameter vs. Overloading\hfill }{15}{subsection.2.7}
\contentsline {section}{\numberline {3}Kapitel 3: Pointer und Referenzen\hfill }{16}{section.3}
\contentsline {subsection}{\numberline {3.1}H\IeC {\"o}here und strukturierte Datentypen\hfill }{16}{subsection.3.1}
\contentsline {subsubsection}{\numberline {3.1.1}H\IeC {\"o}here Datentypen\hfill }{16}{subsubsection.3.1.1}
\contentsline {subsubsection}{\numberline {3.1.2}Strukturierte Datentypen\hfill }{16}{subsubsection.3.1.2}
\contentsline {subsection}{\numberline {3.2}Pointer\hfill }{16}{subsection.3.2}
\contentsline {subsubsection}{\numberline {3.2.1}Adresse\hfill }{16}{subsubsection.3.2.1}
\contentsline {subsubsection}{\numberline {3.2.2}Pointer\hfill }{16}{subsubsection.3.2.2}
\contentsline {subsubsection}{\numberline {3.2.3}Standarddarstellung von Pointern\hfill }{16}{subsubsection.3.2.3}
\contentsline {subsubsection}{\numberline {3.2.4}Pointer und Datentyp\hfill }{17}{subsubsection.3.2.4}
\contentsline {subsubsection}{\numberline {3.2.5}Definition einer Pointervariablen\hfill }{17}{subsubsection.3.2.5}
\contentsline {subsubsection}{\numberline {3.2.6}Initialisierung mit Null-Pointer\hfill }{17}{subsubsection.3.2.6}
\contentsline {subsubsection}{\numberline {3.2.7}Der Adressoperator \& \textbf {(Referenzierung)}\hfill }{17}{subsubsection.3.2.7}
\contentsline {subsubsection}{\numberline {3.2.8}Kopieren von Adressen\hfill }{18}{subsubsection.3.2.8}
\contentsline {subsubsection}{\numberline {3.2.9}Der Inhaltsoperator * \textbf {(Dereferenzierung)}\hfill }{19}{subsubsection.3.2.9}
\contentsline {subsubsection}{\numberline {3.2.10}Darstellung in graphischer Pointernotation\hfill }{19}{subsubsection.3.2.10}
\contentsline {subsubsection}{\numberline {3.2.11}const bei Pointern: Vorsicht\hfill }{20}{subsubsection.3.2.11}
\contentsline {subsubsection}{\numberline {3.2.12}void-Pointer\hfill }{21}{subsubsection.3.2.12}
\contentsline {subsubsection}{\numberline {3.2.13}Pointer auf Funktionen\hfill }{21}{subsubsection.3.2.13}
\contentsline {subsubsection}{\numberline {3.2.14}Interruptvektortabelle: Tabelle von Funktionspointern\hfill }{21}{subsubsection.3.2.14}
\contentsline {subsubsection}{\numberline {3.2.15}Umsetzung von Funktionspointern in C/C++\hfill }{22}{subsubsection.3.2.15}
\contentsline {subsubsection}{\numberline {3.2.16}Beispiel f\IeC {\"u}r Funktionspointer}{22}{subsubsection.3.2.16}
\contentsline {subsection}{\numberline {3.3}Referenzen\hfill }{22}{subsection.3.3}
\contentsline {subsubsection}{\numberline {3.3.1}Was ist eine Referenz?\hfill }{22}{subsubsection.3.3.1}
\contentsline {subsubsection}{\numberline {3.3.2}Syntax von Referenzen\hfill }{23}{subsubsection.3.3.2}
\contentsline {subsubsection}{\numberline {3.3.3}Einsatz von Referenzen\hfill }{23}{subsubsection.3.3.3}
\contentsline {subsubsection}{\numberline {3.3.4}Pointer und Referenzen auf lokale Variablen\hfill }{23}{subsubsection.3.3.4}
\contentsline {subsection}{\numberline {3.4}Zeiger und Referenzen als Parameter und R\IeC {\"u}ckgabewerte\hfill }{23}{subsection.3.4}
\contentsline {subsubsection}{\numberline {3.4.1}Call by Value vs. Call by Reference\hfill }{23}{subsubsection.3.4.1}
\contentsline {subsubsection}{\numberline {3.4.2}3 Beispiele\hfill }{24}{subsubsection.3.4.2}
\contentsline {subsubsection}{\numberline {3.4.3}Call by reference: wann einsetzen?\hfill }{25}{subsubsection.3.4.3}
\contentsline {subsubsection}{\numberline {3.4.4}Merke\hfill }{25}{subsubsection.3.4.4}
\contentsline {section}{\numberline {4}Kapitel 4: Arrays, Dynamische Speicherverwaltung\hfill }{26}{section.4}
\contentsline {subsection}{\numberline {4.1}Arrays: Vektoren\hfill }{26}{subsection.4.1}
\contentsline {subsubsection}{\numberline {4.1.1}Problemstellung\hfill }{26}{subsubsection.4.1.1}
\contentsline {subsubsection}{\numberline {4.1.2}Der Array (Feld, Vektor)\hfill }{26}{subsubsection.4.1.2}
\contentsline {subsubsection}{\numberline {4.1.3}Zugriff auf ein Arrayelement\hfill }{26}{subsubsection.4.1.3}
\contentsline {subsection}{\numberline {4.2}Arrays und Pointer\hfill }{27}{subsection.4.2}
\contentsline {subsubsection}{\numberline {4.2.1}Pro Memoria: Eindimensionales Array (Vektor)\hfill }{27}{subsubsection.4.2.1}
\contentsline {subsubsection}{\numberline {4.2.2}\IeC {\"A}quivalenz von Array- und Pointernotation\hfill }{27}{subsubsection.4.2.2}
\contentsline {subsubsection}{\numberline {4.2.3}Vergleichen von Arrays\hfill }{27}{subsubsection.4.2.3}
\contentsline {subsubsection}{\numberline {4.2.4}Arrayname ist ein nicht modifizierbarer L-Wert\hfill }{28}{subsubsection.4.2.4}
\contentsline {subsubsection}{\numberline {4.2.5}Automatische Initialisierung von Arrays\hfill }{28}{subsubsection.4.2.5}
\contentsline {subsubsection}{\numberline {4.2.6}Explizite Initialisierung von Arrays\hfill }{28}{subsubsection.4.2.6}
\contentsline {subsubsection}{\numberline {4.2.7}Beispiel: Explizite Initialisierung von Arrays\hfill }{28}{subsubsection.4.2.7}
\contentsline {subsubsection}{\numberline {4.2.8}Goodies f\IeC {\"u}r die explizite Initialisierung\hfill }{28}{subsubsection.4.2.8}
\contentsline {subsection}{\numberline {4.3}Mehrdimensionale Arrays\hfill }{29}{subsection.4.3}
\contentsline {subsubsection}{\numberline {4.3.1}Initialisierung eines mehrdimensionalen Arrays\hfill }{29}{subsubsection.4.3.1}
\contentsline {subsection}{\numberline {4.4}\IeC {\"U}bergabe von Arrays und Zeichenketten\hfill }{29}{subsection.4.4}
\contentsline {subsubsection}{\numberline {4.4.1}Beispiel: Array (Vektor) als Parameter\hfill }{30}{subsubsection.4.4.1}
\contentsline {subsubsection}{\numberline {4.4.2}\IeC {\"U}bergabe einer Matrix mittels offenem Array\hfill }{30}{subsubsection.4.4.2}
\contentsline {subsubsection}{\numberline {4.4.3}Zeichenketten (Strings)\hfill }{30}{subsubsection.4.4.3}
\contentsline {subsection}{\numberline {4.5}Dynamische Speicherverwaltung\hfill }{30}{subsection.4.5}
\contentsline {subsubsection}{\numberline {4.5.1}Pro Memoria: Variablen\hfill }{30}{subsubsection.4.5.1}
\contentsline {subsubsection}{\numberline {4.5.2}Dynamische Speicherverwaltung\hfill }{31}{subsubsection.4.5.2}
\contentsline {subsubsection}{\numberline {4.5.3}Dynamische Speicherverwaltung: Syntax\hfill }{31}{subsubsection.4.5.3}
\contentsline {subsubsection}{\numberline {4.5.4}Dynamische Speicherverwaltung: Vorsichtsmassnahmen\hfill }{31}{subsubsection.4.5.4}
\contentsline {subsubsection}{\numberline {4.5.5}Memory Leak, Garbage Collection\hfill }{32}{subsubsection.4.5.5}
\contentsline {subsubsection}{\numberline {4.5.6}Dynamische Allozierung von Arrays\hfill }{32}{subsubsection.4.5.6}
\contentsline {subsubsection}{\numberline {4.5.7}Dynamische Allozierung von Matrizen\hfill }{32}{subsubsection.4.5.7}
\contentsline {subsubsection}{\numberline {4.5.8}Dynamische Matrix mit 4 Zeilen und 3 Spalten\hfill }{32}{subsubsection.4.5.8}
\contentsline {subsubsection}{\numberline {4.5.9}Zugriff auf dynamisch erzeugte Matrix\hfill }{33}{subsubsection.4.5.9}
\contentsline {subsubsection}{\numberline {4.5.10}Dynamische Matrix freigeben\hfill }{34}{subsubsection.4.5.10}
\contentsline {subsubsection}{\numberline {4.5.11}Effizienz der Matriximplementationen\hfill }{35}{subsubsection.4.5.11}
\contentsline {section}{\numberline {5}Kapitel 5: Scope, Deklarationen, Type Casts\hfill }{36}{section.5}
\contentsline {subsection}{\numberline {5.1}Strukturen\hfill }{36}{subsection.5.1}
\contentsline {subsubsection}{\numberline {5.1.1}Strukturen in C++\hfill }{36}{subsubsection.5.1.1}
\contentsline {subsection}{\numberline {5.2}G\IeC {\"u}ltigkeitsbereiche, Namensr\IeC {\"a}ume und Sichtbarkeit\hfill }{36}{subsection.5.2}
\contentsline {subsubsection}{\numberline {5.2.1}G\IeC {\"u}ltigkeitsbereiche von Namen (Scope)\hfill }{36}{subsubsection.5.2.1}
\contentsline {subsubsection}{\numberline {5.2.2}G\IeC {\"u}ltigkeitsbereiche in C++\hfill }{36}{subsubsection.5.2.2}
\contentsline {subsubsection}{\numberline {5.2.3}G\IeC {\"u}ltigkeit (Scope) von Variablen\hfill }{37}{subsubsection.5.2.3}
\contentsline {subsubsection}{\numberline {5.2.4}Lebensdauer von Variablen\hfill }{37}{subsubsection.5.2.4}
\contentsline {subsubsection}{\numberline {5.2.5}Sichtbarkeit von Variablen\hfill }{37}{subsubsection.5.2.5}
\contentsline {subsubsection}{\numberline {5.2.6}Schlussfolgerung (naheliegend aber falsch)\hfill }{37}{subsubsection.5.2.6}
\contentsline {subsubsection}{\numberline {5.2.7}Lebensdauer (grau) und Sichtbarkeit (weiss)}{37}{subsubsection.5.2.7}
\contentsline {subsubsection}{\numberline {5.2.8}Codierstil\hfill }{38}{subsubsection.5.2.8}
\contentsline {subsection}{\numberline {5.3}Namensr\IeC {\"a}ume (Namespaces)\hfill }{38}{subsection.5.3}
\contentsline {subsubsection}{\numberline {5.3.1}Namensr\IeC {\"a}ume\hfill }{38}{subsubsection.5.3.1}
\contentsline {subsubsection}{\numberline {5.3.2}Explizite Namensr\IeC {\"a}ume in C++\hfill }{39}{subsubsection.5.3.2}
\contentsline {subsubsection}{\numberline {5.3.3}C++-Mechanismen f\IeC {\"u}r Namespaces\hfill }{39}{subsubsection.5.3.3}
\contentsline {subsubsection}{\numberline {5.3.4}Deklaration von Namespaces\hfill }{39}{subsubsection.5.3.4}
\contentsline {subsubsection}{\numberline {5.3.5}Deklaration von Namespaces: Beispiel\hfill }{40}{subsubsection.5.3.5}
\contentsline {subsubsection}{\numberline {5.3.6}using-Deklaration\hfill }{40}{subsubsection.5.3.6}
\contentsline {subsubsection}{\numberline {5.3.7}using-Direktive\hfill }{40}{subsubsection.5.3.7}
\contentsline {subsubsection}{\numberline {5.3.8}using namespace kann zu Konflikten f\IeC {\"u}hren\hfill }{41}{subsubsection.5.3.8}
\contentsline {subsubsection}{\numberline {5.3.9}Namenlose Namespaces\hfill }{41}{subsubsection.5.3.9}
\contentsline {subsubsection}{\numberline {5.3.10}Zugriff auf globale Variable mit Scope-Operator\hfill }{41}{subsubsection.5.3.10}
\contentsline {subsection}{\numberline {5.4}Speicherklassen\hfill }{42}{subsection.5.4}
\contentsline {subsubsection}{\numberline {5.4.1}Speicherklassen in C++\hfill }{42}{subsubsection.5.4.1}
\contentsline {subsubsection}{\numberline {5.4.2}Speicherklasse static: Variablen\hfill }{42}{subsubsection.5.4.2}
\contentsline {subsubsection}{\numberline {5.4.3}Speicherklasse static: Funktionen\hfill }{42}{subsubsection.5.4.3}
\contentsline {subsubsection}{\numberline {5.4.4}Speicherklasse extern: Externe Variablen\hfill }{42}{subsubsection.5.4.4}
\contentsline {subsubsection}{\numberline {5.4.5}Typqualifikationen (Kap. 9.2.2)\hfill }{43}{subsubsection.5.4.5}
\contentsline {subsubsection}{\numberline {5.4.6}Funktionsattribute\hfill }{43}{subsubsection.5.4.6}
\contentsline {subsection}{\numberline {5.5}Typdefinitionen\hfill }{43}{subsection.5.5}
\contentsline {subsubsection}{\numberline {5.5.1}typedef zur Vereinbarung eigener Datentypen\hfill }{43}{subsubsection.5.5.1}
\contentsline {subsubsection}{\numberline {5.5.2}Beispiel\hfill }{44}{subsubsection.5.5.2}
\contentsline {subsubsection}{\numberline {5.5.3}Gew\IeC {\"a}hrleistung von Portabilit\IeC {\"a}t\hfill }{44}{subsubsection.5.5.3}
\contentsline {subsubsection}{\numberline {5.5.4}Wie setzt der Compiler ein typedef um?\hfill }{44}{subsubsection.5.5.4}
\contentsline {subsection}{\numberline {5.6}Initialisierung\hfill }{45}{subsection.5.6}
\contentsline {subsection}{\numberline {5.7}Type-Case (Typumwandlungen)\hfill }{45}{subsection.5.7}
\contentsline {subsubsection}{\numberline {5.7.1}Typumwandlungen im Allgemeinen\hfill }{45}{subsubsection.5.7.1}
\contentsline {subsubsection}{\numberline {5.7.2}Implizite Typumwandlung\hfill }{45}{subsubsection.5.7.2}
\contentsline {subsubsection}{\numberline {5.7.3}Explizite Typumwandlung\hfill }{45}{subsubsection.5.7.3}
\contentsline {subsubsection}{\numberline {5.7.4}Explizite Typumwandlung \#1, 2: C-Stil und Funktionsstil\hfill }{45}{subsubsection.5.7.4}
\contentsline {subsubsection}{\numberline {5.7.5}Typumwandlung mit C-Stil und Funktionsstil\hfill }{46}{subsubsection.5.7.5}
\contentsline {subsubsection}{\numberline {5.7.6}Explizite Typumwandlung \#3: const\_cast\hfill }{46}{subsubsection.5.7.6}
\contentsline {subsubsection}{\numberline {5.7.7}Explizite Typumwandlung \#4: static\_cast\hfill }{46}{subsubsection.5.7.7}
\contentsline {subsubsection}{\numberline {5.7.8}Explizite Typumwandlung \#5: dynamic\_cast\hfill }{46}{subsubsection.5.7.8}
\contentsline {subsubsection}{\numberline {5.7.9}Explizite Typumwandlung \#6: reinterpret\_cast\hfill }{46}{subsubsection.5.7.9}
