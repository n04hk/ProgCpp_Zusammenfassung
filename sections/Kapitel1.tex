%!TEX root = ProgCPP_ZF.tex

\part{Einführung}
\section{Charakteristiken von C++}
\begin{itemize}
	\item C++ erlaubt sowohl prozedurale, objektorientierte als auch generische Programmierung\\
	\begin{achtung}
		Nicht jedes C++-Programm ist objektorientiert!
	\end{achtung}
	\item C++ ist sehr mächtig
	\item C++ ist eine Obermenge von C
	\item Syntaktisch ist C++ sehr ähnlich oder identisch zu C
	\item C++ ist sicherer als C
\end{itemize}

\section{Entstehung von C++}
\begin{itemize}
	\item C Ritchie 1971, typisiert
	\item ANSI C seit 1983
	\item C++ Stroustrup 1986, Klassen und OO
	\item Final Standard ISO/ANSI 	ab 1990 
	\vspace{3mm}
	\\ \textbf{ISO/IEC 14882:2003 Programming Languages - C++, aka C++03} 			
	\vspace{3mm}
	\\ \textbf{ISO/IEC 14882:2011 Programming Languages - C++, aka C++11}
	\vspace{3mm}
	\\ \textbf{ISO/IEC 14882:2014 Programming Languages - C++, aka C++14}
\end{itemize}

\section{Welches C++?}
\begin{itemize}
	\item \textbf{Im Modul ProgCPP setzen wir den Standard 14882:2003, d.h. C++03 ein}
	\item Wieso nicht C++11 oder C++14?
	\begin{itemize}
		\item Der neue Standard hat einige interessante Erneuerungen zu bieten, die C++ noch näher an C\# kommen lassen
		\item Durch diese neuen Features wird die Sprache leider nicht einfacher sondern umfangreicher und komplizierter
		\item Der Nutzen von einzelnen Neuerungen ist m.E. fraglich
		\item Bei Embedded Systems wird heute noch mehrheitlich C verwendet. Diejenigen, die C++ einsetzen, nehmen C++03
		\item Ich bin gespannt, ob und wann C++11 im Embedded-Bereich den Durchbruch schafft
	\end{itemize}
\end{itemize}

\section{C++-Unterstützung von Texas Instruments (TI)}
\begin{itemize}
	\item TI als Repräsentant für einen Anbieter von Embedded-Entwicklungsumgebungen
	\item The TI compilers for all devices support
	\begin{itemize}
		\item[\-] C++98 (ISO/IEC 14882:1998)
		\item[\-] C++03 (this is a bug fix update to C++98)
	\end{itemize}
	\item The TI compiler does not support
	\begin{itemize}
		\item[\-] C++ TR1
		\item[\-] C++11 (ISO/IEC 14882:2011)
	\end{itemize}
	\item Noch neuere Versionen erst recht nicht
\end{itemize}
\pagebreak

\begin{multicols}{2}
\section{Hello World!}
\vspace{-\baselineskip}
\begin{minipage}{\linewidth}
\begin{lstlisting}
#include <iostream>
using namespace std;

int main(void)
{
	cout << "Hello World!" << endl;
	return 0;
}
\end{lstlisting}
\end{minipage}
\vfill\null
\columnbreak
\section{C++-Compiler (noch nicht Eclipse)}
Statt \textbf{gcc} (für C-Programme) muss \textbf{g++} (für C++-Programme) oder clang++ verwendet werden:\\

\center{\textbf{g++ -o hello hello.cpp}}\\
\textbf{clang++ -o hello hello.cpp}
\flushleft
\vfill\null
\end{multicols}

\section{Styleguide: Bezeichner (\raisebox{-0.9ex}{\~{ }}Namen)}
\begin{itemize}
	\item Variablen, Konstanten und Objekte
	\begin{itemize}
		\item mit Kleinbuchstaben beginnen
		\item erster Buchstaben von zusammengesetzten Wörtern ist gross (mixed case)
		\item keine Underscores
		\\
		\item[\-] Beispiele: counter, maxSpeed
	\end{itemize}
	\vspace{\baselineskip}
	\item Funktionen
	\begin{itemize}
		\item mit Kleinbuchstaben beginnen
		\item erster Buchstaben von zusammengesetzten Wörtern ist gross (mixed case)
		\item Namen beschreiben Tätigkeiten
		\item keine Underscores
		\\
		\item[\-] Beispiele: getCount(), init(), setMaxSpeed()
	\end{itemize}
	\vspace{\baselineskip}
	\item Klassen, Strukturen, Enums
	\begin{itemize}
		\item mit Grossbuchstaben beginnen
		\item erster Buchstaben von zusammengesetzten Wörtern ist gross (mixed case)
		\item keine Underscores
		\\
		\item[\-] Beispiele: MotorController, Queue, Color
	\end{itemize}
\end{itemize}

\section{Typkonzept}

\subsection{Datentypen}
\begin{itemize}
	\item In C++ gibt es die gleichen Basisdatentypen (plain old data types, POD types) wie in C
	\item Zusätzlich: es gibt einen Typ für boole'sche Werte: \textbf{bool}
	\item Der Typ \textbf{bool} hat die beiden Werte \textbf{true} und \textbf{false}
\end{itemize}

\subsection{{\#}define}
\begin{itemize}
	\item In C oft noch geduldet, in C++ verpönt
	\item \emph{\#define} bewirkt eine reine Textersetzung durch den Präprozessor, umgeht dadurch Syntax- und Typenprüfung
	\item Für die Definition von symbolischen Konstanten soll statt \emph{\#define} das Schlüsselwort \textbf{const} oder \textbf{enum} verwendet werden\\
 	\fcolorbox{red}{white}{\parbox{0.3\linewidth}{schlecht:\\
 		\#define PI 3.14159\\
 		\#define VERSUCHE\_MAX 4}}
	\fcolorbox{green}{white}{\parbox{0.5\linewidth}{gut:\\
		const double pi = 3.14159;\\
		const int versucheMax = 4;\\
		enum\{versucheMax = 4\};\quad //noch besser als const int}}
\end{itemize}

\section{Ausdrücke und Operatoren}
\begin{itemize}
	\item C++ ist hier völlig identisch zu C
	\item Es gibt noch ein paar zusätzliche Operatoren in C++ (z.B. für type casting)
\end{itemize}

\section{Anweisungen}
\begin{itemize}
	\item Die Syntax der Blockanweisung ist identisch zu C
	\item Die Syntax der Steuerstrukturen ist identisch zu C
	\begin{itemize}
		\item Sequenz
		\item Iteration (for, while, do ... while)
		\item Selektion (if, if ... else, switch)
	\end{itemize}
	\item Sprunganweisungen sind auch identisch zu C
	\begin{itemize}
		\item break
		\item continue
		\item return
		\item goto $\rightarrow$ nicht verwenden!!!
	\end{itemize}
\end{itemize}

\section{Streams}

\subsection{Streamkonzept}
\label{sec:streamkonzept}
\begin{itemize}
	\item Ein Stream repräsentiert einen sequentiellen Datenstrom
	\item Die Operatoren auf dem Stream sind << und >>\\
	Für vordefinierte Datentypen sind diese Operatoren schon definiert, für eigene selbstdefinierte Klassen können diese Operatoren überladen werden (\emph{siehe \ref{sec:streamkonzeptOverloading}})
	\item C++ stellt 4 Standardströme zur Verfügung
	\begin{itemize}
		\item cin:	Standard-Eingabestrom, normalerweise die Tastatur
		\item cout:	Standard-Ausgabestrom, normalerweise der Bildschirm
		\item cerr:	Standard-Fehlerausgabestrom, normalerweise der Bildschirm
		\item clog: mit \emph{cerr} gekoppelt
	\end{itemize}
	\item Alle diese Ströme können auch mit einer Datei verbunden werden
\end{itemize}

\subsection{Einsatz von Streams}
\begin{itemize}
	\item In C werden printf() und scanf() mit stdin, stdout, stderr verwendet.
	\item printf() und scanf() könnten in C++ immer noch verwendet werden. Dies soll jedoch im Normalfall vermieden werden.
	\item C++ bietet analog die Streams cin, cout, cerr an.
	\item Der Zugriff auf cin und cout ist einfacher und komfortabler als die Verwendung von printf() und scanf().
	\item cin und cout müssen immer ganz links in einer Befehlszeile stehen. Die Daten kommen von cin (Tastatur, Operator >>) und gehen zu cout (Konsole, Operator <<).
\end{itemize}

\begin{multicols}{2}
\subsection{Ausgabe: Klasse ostream}
\label{sec:ostream}
\begin{itemize}
	\item Methoden für die Ausgabe von vordefinierten Datentypen, z.B.:
		\\ ostream\& operator \flq\flq(int n);
		\\ ostream\& operator \flq\flq(double d);
		\\ ostream\& operator \flq\flq(char c);
	\item Weitere Klassen können diesen Operator überschreiben, z.B.:
		\\ ostream\& operator \flq\flq(std::string str);
	\item Nutzung mit cout (vordefiniertes Objekt der Klasse ostream):
		\\ int i = 45;
		\\cout \flq\flq \grqq Hallo  \grqq \flq\flq i \flq\flq endl;
\end{itemize}
\vfill\null
\columnbreak
\subsection{Eingabe: Klasse istream}
\label{sec:istream}
\begin{itemize}
	\item Methoden für die Eingabe von vordefinierten Datentypen, z.B.:
		\\ istream\& operator \frq\frq(int\& n);
		\\ istream\& operator \frq\frq(double\& d);
		\\ istream\& operator \frq\frq(char\& c);
	\item Weitere Klassen können diesen Operator überschreiben z.B.:
		\\ istream\& operator \frq\frq(std::string\& str);
	\item Nutzung mit cin (vordefiniertes Objekt der Klasse istream):
		\\ double d;
		\\ string str;
		\\ cin \frq\frq d \frq\frq str;
\end{itemize}
\end{multicols}

\subsection{Formatierte Ein- und Ausgabe}
\label{sec:Formatierte Ein- und Ausgabe}
ios, eine Basisklasse von iostream, stellt verschiedene Möglichkeiten (Format Flags) vor, um die Ein- und Ausgabe zu beeinflussen.
Beispiel:\\
cout << \color{red}showbase\color{black} << \color{green}hex\color{black} << 27;	// Ausgabe: \color{red}0x\color{green}1b \color{black}
\vfill
\pagebreak\newpage

\subsubsection{Format-Flags um Überblick {(unvollständig)}}
\label{sec:Format-Flags um Ueberblick}
\rowcolors{1}{gray!25}{gray!5}
\begin{tabularx}{\textwidth}{|p{0.25\textwidth}|X|X|}
	\hline
	\rowcolor{gray!50}\textbf{Flag} & \textbf{Wirkung}\\
	\hline
	boolalpha	& bool-Werte werden textuell ausgegeben\\
	\hline
	dec	& Ausgabe erfolgt dezimal\\
	\hline
	fixed	& Gleitkommazahlen im Fixpunktformat\\
	\hline
	hex	& Ausgabe erfolgt hexadezimal\\
	\hline
	internal	& Ausgabe innerhalb Feld\\
	\hline
	left	& linksbündig\\
	\hline
	oct	& Ausgabe erfolgt oktal\\
	\hline
	right	& rechtsbündig\\
	\hline
	scientific	& Gleitkommazahl wissenschaftlich (Mantisse und Exponent)\\
	\hline
	showbase	& Zahlenbasis wird angezeigt\\
	\hline
	showpoint	& Dezimalpunkt wird immer ausgegeben\\
	\hline
	showpos	& Vorzeichen bei positiven Zahlen anzeigen\\
	\hline
	skipws	& Führende Whitespaces nicht anzeigen\\
	\hline
	unitbuf	& Leert Buffer des Outputstreams nach Schreiben\\
	\hline
	uppercase	& Alle Kleinbuchstaben in Grossbuchstaben wandeln\\
	\hline
\end{tabularx}